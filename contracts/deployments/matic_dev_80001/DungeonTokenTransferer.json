{
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "seller",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "buyer",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[8]",
              "name": "amounts",
              "type": "uint256[8]"
            },
            {
              "internalType": "uint256[]",
              "name": "gears",
              "type": "uint256[]"
            }
          ],
          "indexed": false,
          "internalType": "struct DungeonTokenTransferer.Offer",
          "name": "sale",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[8]",
              "name": "amounts",
              "type": "uint256[8]"
            },
            {
              "internalType": "uint256[]",
              "name": "gears",
              "type": "uint256[]"
            }
          ],
          "indexed": false,
          "internalType": "struct DungeonTokenTransferer.Offer",
          "name": "price",
          "type": "tuple"
        }
      ],
      "name": "Exchange",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "seller",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "buyer",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gearId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "GearSale",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MAX_GEARS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "characterId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "batchTransferElementsIn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "batchTransferElementsOut",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "characterId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        }
      ],
      "name": "batchTransferGearIn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        }
      ],
      "name": "batchTransferGearOut",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "drop",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "dropElements",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[8]",
              "name": "amounts",
              "type": "uint256[8]"
            },
            {
              "internalType": "uint256[]",
              "name": "gears",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct DungeonTokenTransferer.Offer",
          "name": "seller",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[8]",
              "name": "amounts",
              "type": "uint256[8]"
            },
            {
              "internalType": "uint256[]",
              "name": "gears",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct DungeonTokenTransferer.Offer",
          "name": "buyer",
          "type": "tuple"
        }
      ],
      "name": "exchange",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "pick",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "pickElement",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract DungeonInfoFacet",
          "name": "dungeon",
          "type": "address"
        },
        {
          "internalType": "contract Player",
          "name": "player",
          "type": "address"
        },
        {
          "internalType": "contract Gears",
          "name": "gears",
          "type": "address"
        },
        {
          "internalType": "contract Elements",
          "name": "elements",
          "type": "address"
        },
        {
          "internalType": "contract Characters",
          "name": "characters",
          "type": "address"
        }
      ],
      "name": "postUpgrade",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "characterId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadCharacterId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "scavengeElements",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "characterId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadCharacterId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "scavengeGear",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "seller",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "buyer",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gearId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "coins",
          "type": "uint256"
        }
      ],
      "name": "sellGear",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "to",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "subTransferElementsFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "to",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "subTransferGearFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "receipt": {
    "to": null,
    "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
    "contractAddress": "0x0Ea667962f159796D9E2647eBce263A08Ca3C83b",
    "transactionIndex": 0,
    "gasUsed": "2405004",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000080000000000000000000200000000000200000000000000000000000000000000000000000000000004004000000000000000001000000000000000000000000000000100040000008000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xd8e9d152ca0ed46a16f61e86cd35785366ccbd3a070569ca278c5e72ef222ffd",
    "transactionHash": "0xe8aa97e60bcf0351618c3fa9d2670a97eec6de80508549723f50122890917f2c",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 5102133,
        "transactionHash": "0xe8aa97e60bcf0351618c3fa9d2670a97eec6de80508549723f50122890917f2c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x000000000000000000000000000000000000000000000000002ab8b125845800000000000000000000000000000000000000000000000009454df0eea6bd0200000000000000000000000000000000000000000000000056561938bcd053a9050000000000000000000000000000000000000000000000094523383d8138aa000000000000000000000000000000000000000000000000565643f16df5d80105",
        "logIndex": 0,
        "blockHash": "0xd8e9d152ca0ed46a16f61e86cd35785366ccbd3a070569ca278c5e72ef222ffd"
      }
    ],
    "blockNumber": 5102133,
    "cumulativeGasUsed": "2405004",
    "status": 1,
    "byzantium": true
  },
  "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
  "args": [],
  "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent != 2\\n                && room.numActiveCharacters == 0\\n                && monsterIndex == 0\\n                && room.kind != 0\\n            ) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            // TODO can we remove num active characters check?\\n            if (\\n                nextRoom.monsterBlockNumber == 0\\n                    && nextRoom.numActiveCharacters == 0\\n                    && nextRoom.randomEvent != 2\\n                    && _roomsContract.getData(location) == 0\\n            ) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f1ec36f20e07c28bb353e06be846c988c460ff331a26626dbad37150043c706\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n    uint256 internal constant BOUNTY = 2**254;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function _locationToBounty(uint256 location) internal pure returns (uint256 bounty){\\n        return location - LOCATION_ZERO + BOUNTY;\\n    }\\n\\n    function _bountyToLocation(uint256 bounty) internal pure returns (uint256 location){\\n        return location - BOUNTY + LOCATION_ZERO;\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 2; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms, uint256 periods) external pure returns (uint256) {\\n        return _roomsTax(rooms, periods);\\n    }\\n    function _roomsTax(uint256 rooms, uint256 periods) internal pure returns (uint256) {\\n        return (1 + rooms / 10) * periods;\\n    }\\n}\\n\",\"keccak256\":\"0x9315f0352f71ccb136247b1195f32081fc7673024efdfd2b6865fc9609fd12ab\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\nimport \\\"../utils/MetaTransactionReceiver.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"../utils/Constants.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout, MetaTransactionReceiver, Constants {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance,\\n        Pool pool\\n    ) external proxied {\\n        // TODO _setTrustedForwarder(...);\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n        _pool = pool;\\n        pool.register();\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getEnergy(address playerAddress) external view returns (uint256 energy, uint256 freeEnergy) {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    // TODO remove ?\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        _charactersContract.transferFrom(sender, address(_holder), characterId);\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable sender,\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(sender, sender, msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(sender, newDelegate);\\n        }\\n        _holder.enter.value(value)(sender, characterId, name, class, location);\\n        _lastCharacterIds[sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        address sender = _msgSender();\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(sender) != playerAddress) {\\n            require(uint256(_delegates[sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n        uint256 txCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        uint256 freeEnergyFee = (txCharge * 10) / 100; // 10% extra is used for free energy\\n\\n        uint256 poolFee = txCharge * 10; // 1000% is used for UBF\\n\\n        require(energy >= freeEnergyFee + poolFee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + poolFee);\\n        _pool.recordCharge{value: poolFee}(sender, txCharge, poolFee);\\n\\n        if (msg.sender == sender) {\\n            // not metatx : use local private key so need to recharge local balance // TODO remove (once metatx is enabled)\\n            if (msg.sender.balance < MIN_BALANCE) {\\n                uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n                if (balanceToGive >= energy) {\\n                    balanceToGive = energy;\\n                    energy = 0;\\n                } else {\\n                    energy -= balanceToGive;\\n                }\\n\\n                if (balanceToGive > 0) {\\n                    msg.sender.transfer(balanceToGive);\\n                }\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refillAccount(address account) public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, account, msg.value);\\n    }\\n\\n    function refill() public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, sender, msg.value);\\n    }\\n\\n    function _refill(\\n        address payable sender,\\n        address account,\\n        uint256 value\\n    ) internal returns (uint256 refund) {\\n        uint128 energy = _players[account].energy;\\n        energy += uint128(value);\\n        if (energy > uint128(MAX_FOOD)) {\\n            energy = uint128(MAX_FOOD);\\n            refund = energy - MAX_FOOD;\\n        }\\n        _players[account].energy = energy;\\n        emit Refill(account, energy);\\n        if (refund > 0) {\\n            sender.transfer(refund);\\n        }\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        address payable sender = _msgSender();\\n        if (msg.value > 0) {\\n            _refill(sender, sender, msg.value);\\n        }\\n        _addDelegate(sender, _delegate);\\n    }\\n\\n    function _addDelegate(address sender, address payable _delegate) internal {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x68ad10c9793851f62ca8da96537c9e89c813290c6b1d5a19d3dc760dbfdeadb9\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n\\n    Pool _pool;\\n}\\n\",\"keccak256\":\"0xb5c01a684a934ae4742d2cb686ab53ed1d8e72bb7d6231bf440811de6a01dbbb\"},\"src/player/Pool.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ninterface Pool {\\n    function register() external;\\n\\n    function recordCharge(\\n        address account,\\n        uint256 txCharge,\\n        uint256 poolFee\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x28dfcd73f5c9400c1da453ecc67fea0493bec7c463b27b0eb3b8ccb7979e1a35\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"},\"src/utils/Constants.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract Constants {\\n    uint256 public constant MAX_FOOD = 400000000000000000;\\n}\\n\",\"keccak256\":\"0xaf0e49384bb233af73112ec81b17d1a71a68b528a01aa0afd6395506fc17675a\"},\"src/utils/MetaTransactionReceiver.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nabstract contract MetaTransactionReceiver {\\n    bytes32 constant FORWARDER_STORAGE_POSITION = 0xbda473cae6459373242ba82cd14b3b8493956b600be62b2478f52616c8a283de;\\n\\n    function isTrustedForwarder(address forwarder) external returns (bool) {\\n        return _isTrustedForwarder(forwarder);\\n    }\\n\\n    function _msgSender() internal view returns (address payable sender) {\\n        sender = msg.sender;\\n        if (_isTrustedForwarder(sender)) {\\n            bytes memory data = msg.data;\\n            uint256 length = msg.data.length;\\n            assembly {\\n                sender := mload(add(data, length))\\n            }\\n        }\\n    }\\n\\n    function _isTrustedForwarder(address trustedForwarder) internal view returns(bool isTrustedForwarder) {\\n        address currentForwarder;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            currentForwarder := sload(\\n                FORWARDER_STORAGE_POSITION\\n            )\\n        }\\n        return currentForwarder == trustedForwarder;\\n    }\\n\\n    function _setTrustedForwarder(address trustedForwarder) internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                FORWARDER_STORAGE_POSITION,\\n                trustedForwarder\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x331029fe6dd9110f1655d42a32d0d698089923cf3ef38a3daab855745d776392\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea264697066735822122032dc90b9d61a01b60ca0e441ed03ef81129f8f241f319f8cc65caf558a704f3d64736f6c63430006050033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea264697066735822122032dc90b9d61a01b60ca0e441ed03ef81129f8f241f319f8cc65caf558a704f3d64736f6c63430006050033",
  "execute": {
    "methodName": "postUpgrade",
    "args": [
      "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
      "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
      "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
      "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
      "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
    ]
  },
  "history": [
    {
      "abi": [
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "seller",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "buyer",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[8]",
                  "name": "amounts",
                  "type": "uint256[8]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "gears",
                  "type": "uint256[]"
                }
              ],
              "indexed": false,
              "internalType": "struct DungeonTokenTransferer.Offer",
              "name": "sale",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[8]",
                  "name": "amounts",
                  "type": "uint256[8]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "gears",
                  "type": "uint256[]"
                }
              ],
              "indexed": false,
              "internalType": "struct DungeonTokenTransferer.Offer",
              "name": "price",
              "type": "tuple"
            }
          ],
          "name": "Exchange",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "seller",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "buyer",
              "type": "uint256"
            },
            {
              "indexed": true,
              "internalType": "uint256",
              "name": "gearId",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            }
          ],
          "name": "GearSale",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "MAX_GEARS",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "name": "batchTransferElementsIn",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "name": "batchTransferElementsOut",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "ids",
              "type": "uint256[]"
            }
          ],
          "name": "batchTransferGearIn",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256[]",
              "name": "ids",
              "type": "uint256[]"
            }
          ],
          "name": "batchTransferGearOut",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            }
          ],
          "name": "drop",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "name": "dropElements",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[8]",
                  "name": "amounts",
                  "type": "uint256[8]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "gears",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct DungeonTokenTransferer.Offer",
              "name": "seller",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[8]",
                  "name": "amounts",
                  "type": "uint256[8]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "gears",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct DungeonTokenTransferer.Offer",
              "name": "buyer",
              "type": "tuple"
            }
          ],
          "name": "exchange",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            }
          ],
          "name": "pick",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "pickElement",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract DungeonInfoFacet",
              "name": "dungeon",
              "type": "address"
            },
            {
              "internalType": "contract Player",
              "name": "player",
              "type": "address"
            },
            {
              "internalType": "contract Gears",
              "name": "gears",
              "type": "address"
            },
            {
              "internalType": "contract Elements",
              "name": "elements",
              "type": "address"
            },
            {
              "internalType": "contract Characters",
              "name": "characters",
              "type": "address"
            }
          ],
          "name": "postUpgrade",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadCharacterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "scavengeElements",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "characterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadCharacterId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            }
          ],
          "name": "scavengeGear",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "seller",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "buyer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gearId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "coins",
              "type": "uint256"
            }
          ],
          "name": "sellGear",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "to",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "name": "subTransferElementsFrom",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "to",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            }
          ],
          "name": "subTransferGearFrom",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "receipt": {
        "to": null,
        "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
        "contractAddress": "0x993f00fA077175C08e83F0c5b51D1A5BC956209c",
        "transactionIndex": 0,
        "gasUsed": "2405004",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000200000000000000000000000000000000000000040000000004004000000000000000001000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000000000000000100000",
        "blockHash": "0x202c14be64108cbe8d04489b5e6a171a8f32f1d689ca79b7a5508b06c58794ae",
        "transactionHash": "0x9be4e2da4da2234e2ec3e035ea471772c6e007fb1aab2a5ffd60cf1893aab626",
        "logs": [
          {
            "transactionIndex": 0,
            "blockNumber": 4062085,
            "transactionHash": "0x9be4e2da4da2234e2ec3e035ea471772c6e007fb1aab2a5ffd60cf1893aab626",
            "address": "0x0000000000000000000000000000000000001010",
            "topics": [
              "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
              "0x0000000000000000000000000000000000000000000000000000000000001010",
              "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
              "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
            ],
            "data": "0x00000000000000000000000000000000000000000000000000aae2c496116000000000000000000000000000000000000000000000000009480e3386d604d400000000000000000000000000000000000000000000000043c4fdb799e7816c71000000000000000000000000000000000000000000000009476350c23ff37400000000000000000000000000000000000000000000000043c5a89a5e7d92cc71",
            "logIndex": 0,
            "blockHash": "0x202c14be64108cbe8d04489b5e6a171a8f32f1d689ca79b7a5508b06c58794ae"
          }
        ],
        "blockNumber": 4062085,
        "cumulativeGasUsed": "2405004",
        "status": 1,
        "byzantium": true
      },
      "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
      "args": [],
      "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68f9dbe224dd7d110e59cefde276a774269bdc2f69f0550eb87967ea168ba36b\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n    uint256 internal constant BOUNTY = 2**254;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function _locationToBounty(uint256 location) internal pure returns (uint256 bounty){\\n        return location - LOCATION_ZERO + BOUNTY;\\n    }\\n\\n    function _bountyToLocation(uint256 bounty) internal pure returns (uint256 location){\\n        return location - BOUNTY + LOCATION_ZERO;\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms, uint256 periods) external pure returns (uint256) {\\n        return _roomsTax(rooms, periods);\\n    }\\n    function _roomsTax(uint256 rooms, uint256 periods) internal pure returns (uint256) {\\n        return (1 + rooms / 10) * periods;\\n    }\\n}\\n\",\"keccak256\":\"0xdd23a937e6bc3a440c788bd20715643ced16be47b7644aef149d4a0c8c60d3f7\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\nimport \\\"../utils/MetaTransactionReceiver.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"../utils/Constants.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout, MetaTransactionReceiver, Constants {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance,\\n        Pool pool\\n    ) external proxied {\\n        // TODO _setTrustedForwarder(...);\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n        _pool = pool;\\n        pool.register();\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getEnergy(address playerAddress) external view returns (uint256 energy, uint256 freeEnergy) {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    // TODO remove ?\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        _charactersContract.transferFrom(sender, address(_holder), characterId);\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable sender,\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(sender, sender, msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(sender, newDelegate);\\n        }\\n        _holder.enter.value(value)(sender, characterId, name, class, location);\\n        _lastCharacterIds[sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        address sender = _msgSender();\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(sender) != playerAddress) {\\n            require(uint256(_delegates[sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n        uint256 txCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        uint256 freeEnergyFee = (txCharge * 10) / 100; // 10% extra is used for free energy\\n\\n        uint256 poolFee = txCharge * 10; // 1000% is used for UBF\\n\\n        require(energy >= freeEnergyFee + poolFee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + poolFee);\\n        _pool.recordCharge{value: poolFee}(sender, txCharge, poolFee);\\n\\n        if (msg.sender == sender) {\\n            // not metatx : use local private key so need to recharge local balance // TODO remove (once metatx is enabled)\\n            if (msg.sender.balance < MIN_BALANCE) {\\n                uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n                if (balanceToGive >= energy) {\\n                    balanceToGive = energy;\\n                    energy = 0;\\n                } else {\\n                    energy -= balanceToGive;\\n                }\\n\\n                if (balanceToGive > 0) {\\n                    msg.sender.transfer(balanceToGive);\\n                }\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refillAccount(address account) public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, account, msg.value);\\n    }\\n\\n    function refill() public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, sender, msg.value);\\n    }\\n\\n    function _refill(\\n        address payable sender,\\n        address account,\\n        uint256 value\\n    ) internal returns (uint256 refund) {\\n        uint128 energy = _players[account].energy;\\n        energy += uint128(value);\\n        if (energy > uint128(MAX_FOOD)) {\\n            energy = uint128(MAX_FOOD);\\n            refund = energy - MAX_FOOD;\\n        }\\n        _players[account].energy = energy;\\n        emit Refill(account, energy);\\n        if (refund > 0) {\\n            sender.transfer(refund);\\n        }\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        address payable sender = _msgSender();\\n        if (msg.value > 0) {\\n            _refill(sender, sender, msg.value);\\n        }\\n        _addDelegate(sender, _delegate);\\n    }\\n\\n    function _addDelegate(address sender, address payable _delegate) internal {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x68ad10c9793851f62ca8da96537c9e89c813290c6b1d5a19d3dc760dbfdeadb9\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n\\n    Pool _pool;\\n}\\n\",\"keccak256\":\"0xb5c01a684a934ae4742d2cb686ab53ed1d8e72bb7d6231bf440811de6a01dbbb\"},\"src/player/Pool.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ninterface Pool {\\n    function register() external;\\n\\n    function recordCharge(\\n        address account,\\n        uint256 txCharge,\\n        uint256 poolFee\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x28dfcd73f5c9400c1da453ecc67fea0493bec7c463b27b0eb3b8ccb7979e1a35\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"},\"src/utils/Constants.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract Constants {\\n    uint256 public constant MAX_FOOD = 400000000000000000;\\n}\\n\",\"keccak256\":\"0xaf0e49384bb233af73112ec81b17d1a71a68b528a01aa0afd6395506fc17675a\"},\"src/utils/MetaTransactionReceiver.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nabstract contract MetaTransactionReceiver {\\n    bytes32 constant FORWARDER_STORAGE_POSITION = 0xbda473cae6459373242ba82cd14b3b8493956b600be62b2478f52616c8a283de;\\n\\n    function isTrustedForwarder(address forwarder) external returns (bool) {\\n        return _isTrustedForwarder(forwarder);\\n    }\\n\\n    function _msgSender() internal view returns (address payable sender) {\\n        sender = msg.sender;\\n        if (_isTrustedForwarder(sender)) {\\n            bytes memory data = msg.data;\\n            uint256 length = msg.data.length;\\n            assembly {\\n                sender := mload(add(data, length))\\n            }\\n        }\\n    }\\n\\n    function _isTrustedForwarder(address trustedForwarder) internal view returns(bool isTrustedForwarder) {\\n        address currentForwarder;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            currentForwarder := sload(\\n                FORWARDER_STORAGE_POSITION\\n            )\\n        }\\n        return currentForwarder == trustedForwarder;\\n    }\\n\\n    function _setTrustedForwarder(address trustedForwarder) internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                FORWARDER_STORAGE_POSITION,\\n                trustedForwarder\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x331029fe6dd9110f1655d42a32d0d698089923cf3ef38a3daab855745d776392\"}},\"version\":1}",
      "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea264697066735822122016d69aa69d2a7eedf5d446c99b4a3e29f7e1b268c95d6c96b61fa31ebdf5da8364736f6c63430006050033",
      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea264697066735822122016d69aa69d2a7eedf5d446c99b4a3e29f7e1b268c95d6c96b61fa31ebdf5da8364736f6c63430006050033",
      "execute": {
        "methodName": "postUpgrade",
        "args": [
          "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
          "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
          "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
          "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
          "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
        ]
      },
      "history": [
        {
          "abi": [
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "internalType": "uint256",
                  "name": "seller",
                  "type": "uint256"
                },
                {
                  "indexed": true,
                  "internalType": "uint256",
                  "name": "buyer",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[8]",
                      "name": "amounts",
                      "type": "uint256[8]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "gears",
                      "type": "uint256[]"
                    }
                  ],
                  "indexed": false,
                  "internalType": "struct DungeonTokenTransferer.Offer",
                  "name": "sale",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[8]",
                      "name": "amounts",
                      "type": "uint256[8]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "gears",
                      "type": "uint256[]"
                    }
                  ],
                  "indexed": false,
                  "internalType": "struct DungeonTokenTransferer.Offer",
                  "name": "price",
                  "type": "tuple"
                }
              ],
              "name": "Exchange",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "internalType": "uint256",
                  "name": "seller",
                  "type": "uint256"
                },
                {
                  "indexed": true,
                  "internalType": "uint256",
                  "name": "buyer",
                  "type": "uint256"
                },
                {
                  "indexed": true,
                  "internalType": "uint256",
                  "name": "gearId",
                  "type": "uint256"
                },
                {
                  "indexed": false,
                  "internalType": "uint256",
                  "name": "price",
                  "type": "uint256"
                }
              ],
              "name": "GearSale",
              "type": "event"
            },
            {
              "inputs": [],
              "name": "MAX_GEARS",
              "outputs": [
                {
                  "internalType": "uint256",
                  "name": "",
                  "type": "uint256"
                }
              ],
              "stateMutability": "view",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[]",
                  "name": "amounts",
                  "type": "uint256[]"
                }
              ],
              "name": "batchTransferElementsIn",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "to",
                  "type": "address"
                },
                {
                  "internalType": "uint256[]",
                  "name": "amounts",
                  "type": "uint256[]"
                }
              ],
              "name": "batchTransferElementsOut",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[]",
                  "name": "ids",
                  "type": "uint256[]"
                }
              ],
              "name": "batchTransferGearIn",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "to",
                  "type": "address"
                },
                {
                  "internalType": "uint256[]",
                  "name": "ids",
                  "type": "uint256[]"
                }
              ],
              "name": "batchTransferGearOut",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "name": "drop",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256[]",
                  "name": "amounts",
                  "type": "uint256[]"
                }
              ],
              "name": "dropElements",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[8]",
                      "name": "amounts",
                      "type": "uint256[8]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "gears",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct DungeonTokenTransferer.Offer",
                  "name": "seller",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[8]",
                      "name": "amounts",
                      "type": "uint256[8]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "gears",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct DungeonTokenTransferer.Offer",
                  "name": "buyer",
                  "type": "tuple"
                }
              ],
              "name": "exchange",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "name": "pick",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "pickElement",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "contract DungeonInfoFacet",
                  "name": "dungeon",
                  "type": "address"
                },
                {
                  "internalType": "contract Player",
                  "name": "player",
                  "type": "address"
                },
                {
                  "internalType": "contract Gears",
                  "name": "gears",
                  "type": "address"
                },
                {
                  "internalType": "contract Elements",
                  "name": "elements",
                  "type": "address"
                },
                {
                  "internalType": "contract Characters",
                  "name": "characters",
                  "type": "address"
                }
              ],
              "name": "postUpgrade",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "deadCharacterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "scavengeElements",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "characterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "deadCharacterId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "name": "scavengeGear",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "seller",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "buyer",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "gearId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "coins",
                  "type": "uint256"
                }
              ],
              "name": "sellGear",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "to",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "subTransferElementsFrom",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "from",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "to",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "name": "subTransferGearFrom",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            }
          ],
          "receipt": {
            "to": null,
            "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
            "contractAddress": "0x3A2CF44d582815250DE882637A666E73BD745769",
            "transactionIndex": 0,
            "gasUsed": "2405004",
            "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000200000000000000000000000000000000000000040000000004004000000000000000001000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000000000000000100000",
            "blockHash": "0x61371a38ba1241fec79ad373b1b59c658238ffdb36bfb42483afa7e8487192d4",
            "transactionHash": "0xc46d40f95404ab606bc72a7a88f9e51133c22b1a6d7d0c4874b2870ac68f0dee",
            "logs": [
              {
                "transactionIndex": 0,
                "blockNumber": 3330055,
                "transactionHash": "0xc46d40f95404ab606bc72a7a88f9e51133c22b1a6d7d0c4874b2870ac68f0dee",
                "address": "0x0000000000000000000000000000000000001010",
                "topics": [
                  "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                  "0x0000000000000000000000000000000000000000000000000000000000001010",
                  "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                  "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
                ],
                "data": "0x000000000000000000000000000000000000000000000000002ab8b125845800000000000000000000000000000000000000000000000009d331c6277403a000000000000000000000000000000000000000000000000041b776eae7c422e41b000000000000000000000000000000000000000000000009d3070d764e7f4800000000000000000000000000000000000000000000000041b7a1a398e9a73c1b",
                "logIndex": 0,
                "blockHash": "0x61371a38ba1241fec79ad373b1b59c658238ffdb36bfb42483afa7e8487192d4"
              }
            ],
            "blockNumber": 3330055,
            "cumulativeGasUsed": "2405004",
            "status": 1,
            "byzantium": true
          },
          "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
          "args": [],
          "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68f9dbe224dd7d110e59cefde276a774269bdc2f69f0550eb87967ea168ba36b\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms, uint256 periods) external pure returns (uint256) {\\n        return _roomsTax(rooms, periods);\\n    }\\n    function _roomsTax(uint256 rooms, uint256 periods) internal pure returns (uint256) {\\n        return (1 + rooms / 10) * periods;\\n    }\\n}\\n\",\"keccak256\":\"0x06a77b016b74f5c2de7c4c70c694209a29ec8656fb1faa5d628a466e95eed130\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\nimport \\\"../utils/MetaTransactionReceiver.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"../utils/Constants.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout, MetaTransactionReceiver, Constants {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance,\\n        Pool pool\\n    ) external proxied {\\n        // TODO _setTrustedForwarder(...);\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n        _pool = pool;\\n        pool.register();\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getEnergy(address playerAddress) external view returns (uint256 energy, uint256 freeEnergy) {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    // TODO remove ?\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        _charactersContract.transferFrom(sender, address(_holder), characterId);\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable sender,\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(sender, sender, msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(sender, newDelegate);\\n        }\\n        _holder.enter.value(value)(sender, characterId, name, class, location);\\n        _lastCharacterIds[sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        address sender = _msgSender();\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(sender) != playerAddress) {\\n            require(uint256(_delegates[sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n        uint256 txCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        uint256 freeEnergyFee = (txCharge * 10) / 100; // 10% extra is used for free energy\\n\\n        uint256 poolFee = txCharge * 10; // 1000% is used for UBF\\n\\n        require(energy >= freeEnergyFee + poolFee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + poolFee);\\n        _pool.recordCharge{value: poolFee}(sender, txCharge, poolFee);\\n\\n        if (msg.sender == sender) {\\n            // not metatx : use local private key so need to recharge local balance // TODO remove (once metatx is enabled)\\n            if (msg.sender.balance < MIN_BALANCE) {\\n                uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n                if (balanceToGive >= energy) {\\n                    balanceToGive = energy;\\n                    energy = 0;\\n                } else {\\n                    energy -= balanceToGive;\\n                }\\n\\n                if (balanceToGive > 0) {\\n                    msg.sender.transfer(balanceToGive);\\n                }\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refillAccount(address account) public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, account, msg.value);\\n    }\\n\\n    function refill() public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, sender, msg.value);\\n    }\\n\\n    function _refill(\\n        address payable sender,\\n        address account,\\n        uint256 value\\n    ) internal returns (uint256 refund) {\\n        uint128 energy = _players[account].energy;\\n        energy += uint128(value);\\n        if (energy > uint128(MAX_FOOD)) {\\n            energy = uint128(MAX_FOOD);\\n            refund = energy - MAX_FOOD;\\n        }\\n        _players[account].energy = energy;\\n        emit Refill(account, energy);\\n        if (refund > 0) {\\n            sender.transfer(refund);\\n        }\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        address payable sender = _msgSender();\\n        if (msg.value > 0) {\\n            _refill(sender, sender, msg.value);\\n        }\\n        _addDelegate(sender, _delegate);\\n    }\\n\\n    function _addDelegate(address sender, address payable _delegate) internal {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x68ad10c9793851f62ca8da96537c9e89c813290c6b1d5a19d3dc760dbfdeadb9\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n\\n    Pool _pool;\\n}\\n\",\"keccak256\":\"0xb5c01a684a934ae4742d2cb686ab53ed1d8e72bb7d6231bf440811de6a01dbbb\"},\"src/player/Pool.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ninterface Pool {\\n    function register() external;\\n\\n    function recordCharge(\\n        address account,\\n        uint256 txCharge,\\n        uint256 poolFee\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x28dfcd73f5c9400c1da453ecc67fea0493bec7c463b27b0eb3b8ccb7979e1a35\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"},\"src/utils/Constants.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract Constants {\\n    uint256 public constant MAX_FOOD = 400000000000000000;\\n}\\n\",\"keccak256\":\"0xaf0e49384bb233af73112ec81b17d1a71a68b528a01aa0afd6395506fc17675a\"},\"src/utils/MetaTransactionReceiver.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nabstract contract MetaTransactionReceiver {\\n    bytes32 constant FORWARDER_STORAGE_POSITION = 0xbda473cae6459373242ba82cd14b3b8493956b600be62b2478f52616c8a283de;\\n\\n    function isTrustedForwarder(address forwarder) external returns (bool) {\\n        return _isTrustedForwarder(forwarder);\\n    }\\n\\n    function _msgSender() internal view returns (address payable sender) {\\n        sender = msg.sender;\\n        if (_isTrustedForwarder(sender)) {\\n            bytes memory data = msg.data;\\n            uint256 length = msg.data.length;\\n            assembly {\\n                sender := mload(add(data, length))\\n            }\\n        }\\n    }\\n\\n    function _isTrustedForwarder(address trustedForwarder) internal view returns(bool isTrustedForwarder) {\\n        address currentForwarder;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            currentForwarder := sload(\\n                FORWARDER_STORAGE_POSITION\\n            )\\n        }\\n        return currentForwarder == trustedForwarder;\\n    }\\n\\n    function _setTrustedForwarder(address trustedForwarder) internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                FORWARDER_STORAGE_POSITION,\\n                trustedForwarder\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x331029fe6dd9110f1655d42a32d0d698089923cf3ef38a3daab855745d776392\"}},\"version\":1}",
          "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea264697066735822122027ee1ff086908e6c16cdb54bf1b0fa48e047a13d894805fa75a1f503411eb91564736f6c63430006050033",
          "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea264697066735822122027ee1ff086908e6c16cdb54bf1b0fa48e047a13d894805fa75a1f503411eb91564736f6c63430006050033",
          "execute": {
            "methodName": "postUpgrade",
            "args": [
              "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
              "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
              "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
              "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
              "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
            ]
          },
          "history": [
            {
              "abi": [
                {
                  "anonymous": false,
                  "inputs": [
                    {
                      "indexed": true,
                      "internalType": "uint256",
                      "name": "seller",
                      "type": "uint256"
                    },
                    {
                      "indexed": true,
                      "internalType": "uint256",
                      "name": "buyer",
                      "type": "uint256"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[8]",
                          "name": "amounts",
                          "type": "uint256[8]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "gears",
                          "type": "uint256[]"
                        }
                      ],
                      "indexed": false,
                      "internalType": "struct DungeonTokenTransferer.Offer",
                      "name": "sale",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[8]",
                          "name": "amounts",
                          "type": "uint256[8]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "gears",
                          "type": "uint256[]"
                        }
                      ],
                      "indexed": false,
                      "internalType": "struct DungeonTokenTransferer.Offer",
                      "name": "price",
                      "type": "tuple"
                    }
                  ],
                  "name": "Exchange",
                  "type": "event"
                },
                {
                  "anonymous": false,
                  "inputs": [
                    {
                      "indexed": true,
                      "internalType": "uint256",
                      "name": "seller",
                      "type": "uint256"
                    },
                    {
                      "indexed": true,
                      "internalType": "uint256",
                      "name": "buyer",
                      "type": "uint256"
                    },
                    {
                      "indexed": true,
                      "internalType": "uint256",
                      "name": "gearId",
                      "type": "uint256"
                    },
                    {
                      "indexed": false,
                      "internalType": "uint256",
                      "name": "price",
                      "type": "uint256"
                    }
                  ],
                  "name": "GearSale",
                  "type": "event"
                },
                {
                  "inputs": [],
                  "name": "MAX_GEARS",
                  "outputs": [
                    {
                      "internalType": "uint256",
                      "name": "",
                      "type": "uint256"
                    }
                  ],
                  "stateMutability": "view",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "amounts",
                      "type": "uint256[]"
                    }
                  ],
                  "name": "batchTransferElementsIn",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "amounts",
                      "type": "uint256[]"
                    }
                  ],
                  "name": "batchTransferElementsOut",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "ids",
                      "type": "uint256[]"
                    }
                  ],
                  "name": "batchTransferGearIn",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "ids",
                      "type": "uint256[]"
                    }
                  ],
                  "name": "batchTransferGearOut",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    }
                  ],
                  "name": "drop",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "amounts",
                      "type": "uint256[]"
                    }
                  ],
                  "name": "dropElements",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[8]",
                          "name": "amounts",
                          "type": "uint256[8]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "gears",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct DungeonTokenTransferer.Offer",
                      "name": "seller",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[8]",
                          "name": "amounts",
                          "type": "uint256[8]"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "gears",
                          "type": "uint256[]"
                        }
                      ],
                      "internalType": "struct DungeonTokenTransferer.Offer",
                      "name": "buyer",
                      "type": "tuple"
                    }
                  ],
                  "name": "exchange",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    }
                  ],
                  "name": "pick",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "name": "pickElement",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "contract DungeonInfoFacet",
                      "name": "dungeon",
                      "type": "address"
                    },
                    {
                      "internalType": "contract Player",
                      "name": "player",
                      "type": "address"
                    },
                    {
                      "internalType": "contract Gears",
                      "name": "gears",
                      "type": "address"
                    },
                    {
                      "internalType": "contract Elements",
                      "name": "elements",
                      "type": "address"
                    },
                    {
                      "internalType": "contract Characters",
                      "name": "characters",
                      "type": "address"
                    }
                  ],
                  "name": "postUpgrade",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "deadCharacterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "name": "scavengeElements",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "characterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "deadCharacterId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    }
                  ],
                  "name": "scavengeGear",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "seller",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "buyer",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "gearId",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "coins",
                      "type": "uint256"
                    }
                  ],
                  "name": "sellGear",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "to",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "name": "subTransferElementsFrom",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                },
                {
                  "inputs": [
                    {
                      "internalType": "uint256",
                      "name": "from",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "to",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    }
                  ],
                  "name": "subTransferGearFrom",
                  "outputs": [],
                  "stateMutability": "nonpayable",
                  "type": "function"
                }
              ],
              "receipt": {
                "to": null,
                "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                "contractAddress": "0x4e5387FdB91026c41dC99fcb3B89c3F63be2742f",
                "transactionIndex": 0,
                "gasUsed": "2405004",
                "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000200000000000000000000000000000000000000040000000004004000000000000000001000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000000000000000100000",
                "blockHash": "0x184cd614dfea8bf7bc515651d495c56b0734486b8172337d7de581457ed092ad",
                "transactionHash": "0xf39268f7ab92f41b59cefa40b385ebf484b8680a7b8b2238021f593237b289d0",
                "logs": [
                  {
                    "transactionIndex": 0,
                    "blockNumber": 3313532,
                    "transactionHash": "0xf39268f7ab92f41b59cefa40b385ebf484b8680a7b8b2238021f593237b289d0",
                    "address": "0x0000000000000000000000000000000000001010",
                    "topics": [
                      "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                      "0x0000000000000000000000000000000000000000000000000000000000001010",
                      "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                      "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
                    ],
                    "data": "0x0000000000000000000000000000000000000000000000000019a203e34f6800000000000000000000000000000000000000000000000009d46917989004b000000000000000000000000000000000000000000000000041a3d7999c8f9b2a7a000000000000000000000000000000000000000000000009d44f7594acb54800000000000000000000000000000000000000000000000041a3f13ba072ea927a",
                    "logIndex": 0,
                    "blockHash": "0x184cd614dfea8bf7bc515651d495c56b0734486b8172337d7de581457ed092ad"
                  }
                ],
                "blockNumber": 3313532,
                "cumulativeGasUsed": "2405004",
                "status": 1,
                "byzantium": true
              },
              "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
              "args": [],
              "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68f9dbe224dd7d110e59cefde276a774269bdc2f69f0550eb87967ea168ba36b\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xfadb089d964cfe06a8e27c6d5f22385a039f399ef01cacf019f87b2fd2a0549c\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\nimport \\\"../utils/MetaTransactionReceiver.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"../utils/Constants.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout, MetaTransactionReceiver, Constants {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance,\\n        Pool pool\\n    ) external proxied {\\n        // TODO _setTrustedForwarder(...);\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n        _pool = pool;\\n        pool.register();\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getEnergy(address playerAddress) external view returns (uint256 energy, uint256 freeEnergy) {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    // TODO remove ?\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        _charactersContract.transferFrom(sender, address(_holder), characterId);\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable sender,\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(sender, sender, msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(sender, newDelegate);\\n        }\\n        _holder.enter.value(value)(sender, characterId, name, class, location);\\n        _lastCharacterIds[sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        address sender = _msgSender();\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(sender) != playerAddress) {\\n            require(uint256(_delegates[sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n        uint256 txCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        uint256 freeEnergyFee = (txCharge * 10) / 100; // 10% extra is used for free energy\\n\\n        uint256 poolFee = txCharge * 10; // 1000% is used for UBF\\n\\n        require(energy >= freeEnergyFee + poolFee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + poolFee);\\n        _pool.recordCharge{value: poolFee}(sender, txCharge, poolFee);\\n\\n        if (msg.sender == sender) {\\n            // not metatx : use local private key so need to recharge local balance // TODO remove (once metatx is enabled)\\n            if (msg.sender.balance < MIN_BALANCE) {\\n                uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n                if (balanceToGive >= energy) {\\n                    balanceToGive = energy;\\n                    energy = 0;\\n                } else {\\n                    energy -= balanceToGive;\\n                }\\n\\n                if (balanceToGive > 0) {\\n                    msg.sender.transfer(balanceToGive);\\n                }\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refillAccount(address account) public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, account, msg.value);\\n    }\\n\\n    function refill() public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, sender, msg.value);\\n    }\\n\\n    function _refill(\\n        address payable sender,\\n        address account,\\n        uint256 value\\n    ) internal returns (uint256 refund) {\\n        uint128 energy = _players[account].energy;\\n        energy += uint128(value);\\n        if (energy > uint128(MAX_FOOD)) {\\n            energy = uint128(MAX_FOOD);\\n            refund = energy - MAX_FOOD;\\n        }\\n        _players[account].energy = energy;\\n        emit Refill(account, energy);\\n        if (refund > 0) {\\n            sender.transfer(refund);\\n        }\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        address payable sender = _msgSender();\\n        if (msg.value > 0) {\\n            _refill(sender, sender, msg.value);\\n        }\\n        _addDelegate(sender, _delegate);\\n    }\\n\\n    function _addDelegate(address sender, address payable _delegate) internal {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x68ad10c9793851f62ca8da96537c9e89c813290c6b1d5a19d3dc760dbfdeadb9\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n\\n    Pool _pool;\\n}\\n\",\"keccak256\":\"0xb5c01a684a934ae4742d2cb686ab53ed1d8e72bb7d6231bf440811de6a01dbbb\"},\"src/player/Pool.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ninterface Pool {\\n    function register() external;\\n\\n    function recordCharge(\\n        address account,\\n        uint256 txCharge,\\n        uint256 poolFee\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x28dfcd73f5c9400c1da453ecc67fea0493bec7c463b27b0eb3b8ccb7979e1a35\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"},\"src/utils/Constants.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract Constants {\\n    uint256 public constant MAX_FOOD = 400000000000000000;\\n}\\n\",\"keccak256\":\"0xaf0e49384bb233af73112ec81b17d1a71a68b528a01aa0afd6395506fc17675a\"},\"src/utils/MetaTransactionReceiver.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nabstract contract MetaTransactionReceiver {\\n    bytes32 constant FORWARDER_STORAGE_POSITION = 0xbda473cae6459373242ba82cd14b3b8493956b600be62b2478f52616c8a283de;\\n\\n    function isTrustedForwarder(address forwarder) external returns (bool) {\\n        return _isTrustedForwarder(forwarder);\\n    }\\n\\n    function _msgSender() internal view returns (address payable sender) {\\n        sender = msg.sender;\\n        if (_isTrustedForwarder(sender)) {\\n            bytes memory data = msg.data;\\n            uint256 length = msg.data.length;\\n            assembly {\\n                sender := mload(add(data, length))\\n            }\\n        }\\n    }\\n\\n    function _isTrustedForwarder(address trustedForwarder) internal view returns(bool isTrustedForwarder) {\\n        address currentForwarder;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            currentForwarder := sload(\\n                FORWARDER_STORAGE_POSITION\\n            )\\n        }\\n        return currentForwarder == trustedForwarder;\\n    }\\n\\n    function _setTrustedForwarder(address trustedForwarder) internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                FORWARDER_STORAGE_POSITION,\\n                trustedForwarder\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x331029fe6dd9110f1655d42a32d0d698089923cf3ef38a3daab855745d776392\"}},\"version\":1}",
              "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220cc78c822527ecf7cc4435df4cb0e203d7d2e075caf9754611746cb3b343443a664736f6c63430006050033",
              "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220cc78c822527ecf7cc4435df4cb0e203d7d2e075caf9754611746cb3b343443a664736f6c63430006050033",
              "execute": {
                "methodName": "postUpgrade",
                "args": [
                  "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                  "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                  "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                  "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                  "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                ]
              },
              "history": [
                {
                  "abi": [
                    {
                      "anonymous": false,
                      "inputs": [
                        {
                          "indexed": true,
                          "internalType": "uint256",
                          "name": "seller",
                          "type": "uint256"
                        },
                        {
                          "indexed": true,
                          "internalType": "uint256",
                          "name": "buyer",
                          "type": "uint256"
                        },
                        {
                          "components": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[8]",
                              "name": "amounts",
                              "type": "uint256[8]"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "gears",
                              "type": "uint256[]"
                            }
                          ],
                          "indexed": false,
                          "internalType": "struct DungeonTokenTransferer.Offer",
                          "name": "sale",
                          "type": "tuple"
                        },
                        {
                          "components": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[8]",
                              "name": "amounts",
                              "type": "uint256[8]"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "gears",
                              "type": "uint256[]"
                            }
                          ],
                          "indexed": false,
                          "internalType": "struct DungeonTokenTransferer.Offer",
                          "name": "price",
                          "type": "tuple"
                        }
                      ],
                      "name": "Exchange",
                      "type": "event"
                    },
                    {
                      "anonymous": false,
                      "inputs": [
                        {
                          "indexed": true,
                          "internalType": "uint256",
                          "name": "seller",
                          "type": "uint256"
                        },
                        {
                          "indexed": true,
                          "internalType": "uint256",
                          "name": "buyer",
                          "type": "uint256"
                        },
                        {
                          "indexed": true,
                          "internalType": "uint256",
                          "name": "gearId",
                          "type": "uint256"
                        },
                        {
                          "indexed": false,
                          "internalType": "uint256",
                          "name": "price",
                          "type": "uint256"
                        }
                      ],
                      "name": "GearSale",
                      "type": "event"
                    },
                    {
                      "inputs": [],
                      "name": "MAX_GEARS",
                      "outputs": [
                        {
                          "internalType": "uint256",
                          "name": "",
                          "type": "uint256"
                        }
                      ],
                      "stateMutability": "view",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "amounts",
                          "type": "uint256[]"
                        }
                      ],
                      "name": "batchTransferElementsIn",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "address",
                          "name": "to",
                          "type": "address"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "amounts",
                          "type": "uint256[]"
                        }
                      ],
                      "name": "batchTransferElementsOut",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "ids",
                          "type": "uint256[]"
                        }
                      ],
                      "name": "batchTransferGearIn",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "address",
                          "name": "to",
                          "type": "address"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "ids",
                          "type": "uint256[]"
                        }
                      ],
                      "name": "batchTransferGearOut",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        }
                      ],
                      "name": "drop",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256[]",
                          "name": "amounts",
                          "type": "uint256[]"
                        }
                      ],
                      "name": "dropElements",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "components": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[8]",
                              "name": "amounts",
                              "type": "uint256[8]"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "gears",
                              "type": "uint256[]"
                            }
                          ],
                          "internalType": "struct DungeonTokenTransferer.Offer",
                          "name": "seller",
                          "type": "tuple"
                        },
                        {
                          "components": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[8]",
                              "name": "amounts",
                              "type": "uint256[8]"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "gears",
                              "type": "uint256[]"
                            }
                          ],
                          "internalType": "struct DungeonTokenTransferer.Offer",
                          "name": "buyer",
                          "type": "tuple"
                        }
                      ],
                      "name": "exchange",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        }
                      ],
                      "name": "pick",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "amount",
                          "type": "uint256"
                        }
                      ],
                      "name": "pickElement",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "contract DungeonInfoFacet",
                          "name": "dungeon",
                          "type": "address"
                        },
                        {
                          "internalType": "contract Player",
                          "name": "player",
                          "type": "address"
                        },
                        {
                          "internalType": "contract Gears",
                          "name": "gears",
                          "type": "address"
                        },
                        {
                          "internalType": "contract Elements",
                          "name": "elements",
                          "type": "address"
                        },
                        {
                          "internalType": "contract Characters",
                          "name": "characters",
                          "type": "address"
                        }
                      ],
                      "name": "postUpgrade",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "deadCharacterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "amount",
                          "type": "uint256"
                        }
                      ],
                      "name": "scavengeElements",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "characterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "deadCharacterId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        }
                      ],
                      "name": "scavengeGear",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "seller",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "buyer",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "gearId",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "coins",
                          "type": "uint256"
                        }
                      ],
                      "name": "sellGear",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "to",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "amount",
                          "type": "uint256"
                        }
                      ],
                      "name": "subTransferElementsFrom",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    },
                    {
                      "inputs": [
                        {
                          "internalType": "uint256",
                          "name": "from",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "to",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        }
                      ],
                      "name": "subTransferGearFrom",
                      "outputs": [],
                      "stateMutability": "nonpayable",
                      "type": "function"
                    }
                  ],
                  "receipt": {
                    "to": null,
                    "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                    "contractAddress": "0xf756470833a30d188DF047b70A11B8AE077AAc0A",
                    "transactionIndex": 0,
                    "gasUsed": "2405004",
                    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000080000000000000000000200000000000200000000000000000000000000000000000000000000000004004000000000000000001000000000000000000000000000000100040000008000000000000000000000000000000000000000000000000000000000000100000",
                    "blockHash": "0xedb0e95d0e203df0d8145a4345185e1501664b8e3afaf2e6494fbc68acfcaef0",
                    "transactionHash": "0x74c77550477b61e179c49590aa76a5325119eef6b1e016dcdecaeca2255969b0",
                    "logs": [
                      {
                        "transactionIndex": 0,
                        "blockNumber": 3224697,
                        "transactionHash": "0x74c77550477b61e179c49590aa76a5325119eef6b1e016dcdecaeca2255969b0",
                        "address": "0x0000000000000000000000000000000000001010",
                        "topics": [
                          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                          "0x0000000000000000000000000000000000000000000000000000000000001010",
                          "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
                        ],
                        "data": "0x0000000000000000000000000000000000000000000000000019a203e34f68000000000000000000000000000000000000000000000000202ba2f864b6256000000000000000000000000000000000000000000000000050c49e67c133beac2a0000000000000000000000000000000000000000000000202b895660d2d5f800000000000000000000000000000000000000000000000050c4b809c5170e142a",
                        "logIndex": 0,
                        "blockHash": "0xedb0e95d0e203df0d8145a4345185e1501664b8e3afaf2e6494fbc68acfcaef0"
                      }
                    ],
                    "blockNumber": 3224697,
                    "cumulativeGasUsed": "2405004",
                    "status": 1,
                    "byzantium": true
                  },
                  "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
                  "args": [],
                  "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68f9dbe224dd7d110e59cefde276a774269bdc2f69f0550eb87967ea168ba36b\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xfadb089d964cfe06a8e27c6d5f22385a039f399ef01cacf019f87b2fd2a0549c\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\nimport \\\"../utils/MetaTransactionReceiver.sol\\\";\\nimport \\\"./Pool.sol\\\";\\nimport \\\"../utils/Constants.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout, MetaTransactionReceiver, Constants {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance,\\n        Pool pool\\n    ) external proxied {\\n        // TODO _setTrustedForwarder(...);\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n        _pool = pool;\\n        pool.register();\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getEnergy(address playerAddress) external view returns (uint256 energy, uint256 freeEnergy) {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    // TODO remove ?\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        address payable sender = _msgSender();\\n        _charactersContract.transferFrom(sender, address(_holder), characterId);\\n        _enter(sender, newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable sender,\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(sender, sender, msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(sender, newDelegate);\\n        }\\n        _holder.enter.value(value)(sender, characterId, name, class, location);\\n        _lastCharacterIds[sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        address sender = _msgSender();\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(sender) != playerAddress) {\\n            require(uint256(_delegates[sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        uint256 txCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        uint256 freeEnergyFee = (txCharge * 10) / 100; // 10% extra is used for free energy\\n\\n        uint256 poolFee = txCharge * 10; // 1000% is used for UBF\\n\\n        require(energy >= freeEnergyFee + poolFee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + poolFee);\\n        _pool.recordCharge{value: poolFee}(sender, txCharge, poolFee);\\n\\n        if (msg.sender == sender) {\\n            // not metatx : use local private key so need to recharge local balance // TODO remove (once metatx is enabled)\\n            if (msg.sender.balance < MIN_BALANCE) {\\n                uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n                if (balanceToGive >= energy) {\\n                    balanceToGive = energy;\\n                    energy = 0;\\n                } else {\\n                    energy -= balanceToGive;\\n                }\\n\\n                if (balanceToGive > 0) {\\n                    msg.sender.transfer(balanceToGive);\\n                }\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refillAccount(address account) public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, account, msg.value);\\n    }\\n\\n    function refill() public payable {\\n        address payable sender = _msgSender();\\n        _refill(sender, sender, msg.value);\\n    }\\n\\n    function _refill(\\n        address payable sender,\\n        address account,\\n        uint256 value\\n    ) internal returns (uint256 refund) {\\n        uint128 energy = _players[account].energy;\\n        energy += uint128(value);\\n        if (energy > uint128(MAX_FOOD)) {\\n            energy = uint128(MAX_FOOD);\\n            refund = energy - MAX_FOOD;\\n        }\\n        _players[account].energy = energy;\\n        emit Refill(account, energy);\\n        if (refund > 0) {\\n            sender.transfer(refund);\\n        }\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        address payable sender = _msgSender();\\n        if (msg.value > 0) {\\n            _refill(sender, sender, msg.value);\\n        }\\n        _addDelegate(sender, _delegate);\\n    }\\n\\n    function _addDelegate(address sender, address payable _delegate) internal {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x567a94a5ab6a0958900ca68564ef3bd39cd3c0aac890d6401435a4d0bfff3c02\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n\\n    Pool _pool;\\n}\\n\",\"keccak256\":\"0xb5c01a684a934ae4742d2cb686ab53ed1d8e72bb7d6231bf440811de6a01dbbb\"},\"src/player/Pool.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ninterface Pool {\\n    function register() external;\\n\\n    function recordCharge(\\n        address account,\\n        uint256 txCharge,\\n        uint256 poolFee\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x28dfcd73f5c9400c1da453ecc67fea0493bec7c463b27b0eb3b8ccb7979e1a35\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"},\"src/utils/Constants.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract Constants {\\n    uint256 public constant MAX_FOOD = 400000000000000000;\\n}\\n\",\"keccak256\":\"0xaf0e49384bb233af73112ec81b17d1a71a68b528a01aa0afd6395506fc17675a\"},\"src/utils/MetaTransactionReceiver.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nabstract contract MetaTransactionReceiver {\\n    bytes32 constant FORWARDER_STORAGE_POSITION = 0xbda473cae6459373242ba82cd14b3b8493956b600be62b2478f52616c8a283de;\\n\\n    function isTrustedForwarder(address forwarder) external returns (bool) {\\n        return _isTrustedForwarder(forwarder);\\n    }\\n\\n    function _msgSender() internal view returns (address payable sender) {\\n        sender = msg.sender;\\n        if (_isTrustedForwarder(sender)) {\\n            bytes memory data = msg.data;\\n            uint256 length = msg.data.length;\\n            assembly {\\n                sender := mload(add(data, length))\\n            }\\n        }\\n    }\\n\\n    function _isTrustedForwarder(address trustedForwarder) internal view returns(bool isTrustedForwarder) {\\n        address currentForwarder;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            currentForwarder := sload(\\n                FORWARDER_STORAGE_POSITION\\n            )\\n        }\\n        return currentForwarder == trustedForwarder;\\n    }\\n\\n    function _setTrustedForwarder(address trustedForwarder) internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(\\n                FORWARDER_STORAGE_POSITION,\\n                trustedForwarder\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x331029fe6dd9110f1655d42a32d0d698089923cf3ef38a3daab855745d776392\"}},\"version\":1}",
                  "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220e3e56a209dcdeb930eb3be3e359a81a1a6e79428811cc862e367efeb5810ef4364736f6c63430006050033",
                  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220e3e56a209dcdeb930eb3be3e359a81a1a6e79428811cc862e367efeb5810ef4364736f6c63430006050033",
                  "execute": {
                    "methodName": "postUpgrade",
                    "args": [
                      "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                      "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                      "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                      "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                      "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                    ]
                  },
                  "history": [
                    {
                      "abi": [
                        {
                          "anonymous": false,
                          "inputs": [
                            {
                              "indexed": true,
                              "internalType": "uint256",
                              "name": "seller",
                              "type": "uint256"
                            },
                            {
                              "indexed": true,
                              "internalType": "uint256",
                              "name": "buyer",
                              "type": "uint256"
                            },
                            {
                              "components": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[8]",
                                  "name": "amounts",
                                  "type": "uint256[8]"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "gears",
                                  "type": "uint256[]"
                                }
                              ],
                              "indexed": false,
                              "internalType": "struct DungeonTokenTransferer.Offer",
                              "name": "sale",
                              "type": "tuple"
                            },
                            {
                              "components": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[8]",
                                  "name": "amounts",
                                  "type": "uint256[8]"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "gears",
                                  "type": "uint256[]"
                                }
                              ],
                              "indexed": false,
                              "internalType": "struct DungeonTokenTransferer.Offer",
                              "name": "price",
                              "type": "tuple"
                            }
                          ],
                          "name": "Exchange",
                          "type": "event"
                        },
                        {
                          "anonymous": false,
                          "inputs": [
                            {
                              "indexed": true,
                              "internalType": "uint256",
                              "name": "seller",
                              "type": "uint256"
                            },
                            {
                              "indexed": true,
                              "internalType": "uint256",
                              "name": "buyer",
                              "type": "uint256"
                            },
                            {
                              "indexed": true,
                              "internalType": "uint256",
                              "name": "gearId",
                              "type": "uint256"
                            },
                            {
                              "indexed": false,
                              "internalType": "uint256",
                              "name": "price",
                              "type": "uint256"
                            }
                          ],
                          "name": "GearSale",
                          "type": "event"
                        },
                        {
                          "inputs": [],
                          "name": "MAX_GEARS",
                          "outputs": [
                            {
                              "internalType": "uint256",
                              "name": "",
                              "type": "uint256"
                            }
                          ],
                          "stateMutability": "view",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "amounts",
                              "type": "uint256[]"
                            }
                          ],
                          "name": "batchTransferElementsIn",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "address",
                              "name": "to",
                              "type": "address"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "amounts",
                              "type": "uint256[]"
                            }
                          ],
                          "name": "batchTransferElementsOut",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "ids",
                              "type": "uint256[]"
                            }
                          ],
                          "name": "batchTransferGearIn",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "address",
                              "name": "to",
                              "type": "address"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "ids",
                              "type": "uint256[]"
                            }
                          ],
                          "name": "batchTransferGearOut",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            }
                          ],
                          "name": "drop",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256[]",
                              "name": "amounts",
                              "type": "uint256[]"
                            }
                          ],
                          "name": "dropElements",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "components": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[8]",
                                  "name": "amounts",
                                  "type": "uint256[8]"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "gears",
                                  "type": "uint256[]"
                                }
                              ],
                              "internalType": "struct DungeonTokenTransferer.Offer",
                              "name": "seller",
                              "type": "tuple"
                            },
                            {
                              "components": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[8]",
                                  "name": "amounts",
                                  "type": "uint256[8]"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "gears",
                                  "type": "uint256[]"
                                }
                              ],
                              "internalType": "struct DungeonTokenTransferer.Offer",
                              "name": "buyer",
                              "type": "tuple"
                            }
                          ],
                          "name": "exchange",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            }
                          ],
                          "name": "pick",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "amount",
                              "type": "uint256"
                            }
                          ],
                          "name": "pickElement",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "contract DungeonInfoFacet",
                              "name": "dungeon",
                              "type": "address"
                            },
                            {
                              "internalType": "contract Player",
                              "name": "player",
                              "type": "address"
                            },
                            {
                              "internalType": "contract Gears",
                              "name": "gears",
                              "type": "address"
                            },
                            {
                              "internalType": "contract Elements",
                              "name": "elements",
                              "type": "address"
                            },
                            {
                              "internalType": "contract Characters",
                              "name": "characters",
                              "type": "address"
                            }
                          ],
                          "name": "postUpgrade",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "deadCharacterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "amount",
                              "type": "uint256"
                            }
                          ],
                          "name": "scavengeElements",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "characterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "deadCharacterId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            }
                          ],
                          "name": "scavengeGear",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "seller",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "buyer",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "gearId",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "coins",
                              "type": "uint256"
                            }
                          ],
                          "name": "sellGear",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "to",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "amount",
                              "type": "uint256"
                            }
                          ],
                          "name": "subTransferElementsFrom",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        },
                        {
                          "inputs": [
                            {
                              "internalType": "uint256",
                              "name": "from",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "to",
                              "type": "uint256"
                            },
                            {
                              "internalType": "uint256",
                              "name": "id",
                              "type": "uint256"
                            }
                          ],
                          "name": "subTransferGearFrom",
                          "outputs": [],
                          "stateMutability": "nonpayable",
                          "type": "function"
                        }
                      ],
                      "receipt": {
                        "to": null,
                        "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                        "contractAddress": "0x9A53d1a8F589Db6Ea09EA38717Fb958B8A4c23c8",
                        "transactionIndex": 0,
                        "gasUsed": "2405004",
                        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000080000000000000000000200000000000200000000000000000000000000000000000000000000000004004000000000000000001000000000000000000000000000000100040000008000000000000000000000000000000000000000000000000000000000000100000",
                        "blockHash": "0x624798dff052fa8a36cf0e9320ae12838e9648690ea19843c5b6266d86336394",
                        "transactionHash": "0xe8f247ca10820297e0513ab118bf72e6e3719d1da3e3d7774443c72edaf011b9",
                        "logs": [
                          {
                            "transactionIndex": 0,
                            "blockNumber": 2964287,
                            "transactionHash": "0xe8f247ca10820297e0513ab118bf72e6e3719d1da3e3d7774443c72edaf011b9",
                            "address": "0x0000000000000000000000000000000000001010",
                            "topics": [
                              "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                              "0x0000000000000000000000000000000000000000000000000000000000001010",
                              "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                              "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
                            ],
                            "data": "0x000000000000000000000000000000000000000000000000002ab8b1258458000000000000000000000000000000000000000000000000221648fddea67b440000000000000000000000000000000000000000000000004ff8c1dc86297913cc000000000000000000000000000000000000000000000022161e452d80f6ec0000000000000000000000000000000000000000000000004ff8ec95374efd6bcc",
                            "logIndex": 0,
                            "blockHash": "0x624798dff052fa8a36cf0e9320ae12838e9648690ea19843c5b6266d86336394"
                          }
                        ],
                        "blockNumber": 2964287,
                        "cumulativeGasUsed": "2405004",
                        "status": 1,
                        "byzantium": true
                      },
                      "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
                      "args": [],
                      "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68f9dbe224dd7d110e59cefde276a774269bdc2f69f0550eb87967ea168ba36b\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xfadb089d964cfe06a8e27c6d5f22385a039f399ef01cacf019f87b2fd2a0549c\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance\\n    ) external proxied {\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        _charactersContract.transferFrom(msg.sender, address(_holder), characterId);\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(newDelegate);\\n        }\\n        _holder.enter.value(value)(msg.sender, characterId, name, class, location);\\n        _lastCharacterIds[msg.sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(msg.sender) != playerAddress) {\\n            require(uint256(_delegates[msg.sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        uint256 balanceCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        // TODO remove *10\\n        uint256 freeEnergyFee = (balanceCharge * 10) / 100;\\n        // TODO remove *10\\n        uint256 fee = balanceCharge * 10;\\n        require(energy >= freeEnergyFee + fee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + fee);\\n        _feeRecipient.send(fee);\\n        // TODO _feeRecipient as Pool\\n\\n        // TODO use Metatx instead of local private key holding fund\\n        if (msg.sender.balance < MIN_BALANCE) {\\n            uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n            if (balanceToGive >= energy) {\\n                balanceToGive = energy;\\n                energy = 0;\\n            } else {\\n                energy -= balanceToGive;\\n            }\\n\\n            if (balanceToGive > 0) {\\n                msg.sender.transfer(balanceToGive);\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refill() public payable {\\n        _refill(msg.value);\\n    }\\n\\n    function _refill(uint256 value) internal {\\n        _players[msg.sender].energy += uint128(value);\\n        emit Refill(msg.sender, _players[msg.sender].energy);\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        if (msg.value > 0) {\\n            _refill(msg.value);\\n        }\\n        _addDelegate(_delegate);\\n    }\\n\\n    function _addDelegate(address payable _delegate) public payable {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[msg.sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[msg.sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = msg.sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x1b29df1bc9d7eb406726977624a9b77b61d2cd1a4ff5b1e5a45e9378ae0e1b9c\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n}\\n\",\"keccak256\":\"0x51937d1f4fe454e2fceadab8545288a8af637783ac0f5b4b3cb5996808645dbf\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"}},\"version\":1}",
                      "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220aab9d8cc081c7b665f2c9d14d283d91b9d8be340a192897c9a9162fca74cfcb864736f6c63430006050033",
                      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220aab9d8cc081c7b665f2c9d14d283d91b9d8be340a192897c9a9162fca74cfcb864736f6c63430006050033",
                      "execute": {
                        "methodName": "postUpgrade",
                        "args": [
                          "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                          "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                          "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                          "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                          "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                        ]
                      },
                      "history": [
                        {
                          "abi": [
                            {
                              "anonymous": false,
                              "inputs": [
                                {
                                  "indexed": true,
                                  "internalType": "uint256",
                                  "name": "seller",
                                  "type": "uint256"
                                },
                                {
                                  "indexed": true,
                                  "internalType": "uint256",
                                  "name": "buyer",
                                  "type": "uint256"
                                },
                                {
                                  "components": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[8]",
                                      "name": "amounts",
                                      "type": "uint256[8]"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "gears",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "indexed": false,
                                  "internalType": "struct DungeonTokenTransferer.Offer",
                                  "name": "sale",
                                  "type": "tuple"
                                },
                                {
                                  "components": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[8]",
                                      "name": "amounts",
                                      "type": "uint256[8]"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "gears",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "indexed": false,
                                  "internalType": "struct DungeonTokenTransferer.Offer",
                                  "name": "price",
                                  "type": "tuple"
                                }
                              ],
                              "name": "Exchange",
                              "type": "event"
                            },
                            {
                              "anonymous": false,
                              "inputs": [
                                {
                                  "indexed": true,
                                  "internalType": "uint256",
                                  "name": "seller",
                                  "type": "uint256"
                                },
                                {
                                  "indexed": true,
                                  "internalType": "uint256",
                                  "name": "buyer",
                                  "type": "uint256"
                                },
                                {
                                  "indexed": true,
                                  "internalType": "uint256",
                                  "name": "gearId",
                                  "type": "uint256"
                                },
                                {
                                  "indexed": false,
                                  "internalType": "uint256",
                                  "name": "price",
                                  "type": "uint256"
                                }
                              ],
                              "name": "GearSale",
                              "type": "event"
                            },
                            {
                              "inputs": [],
                              "name": "MAX_GEARS",
                              "outputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "",
                                  "type": "uint256"
                                }
                              ],
                              "stateMutability": "view",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "amounts",
                                  "type": "uint256[]"
                                }
                              ],
                              "name": "batchTransferElementsIn",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "address",
                                  "name": "to",
                                  "type": "address"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "amounts",
                                  "type": "uint256[]"
                                }
                              ],
                              "name": "batchTransferElementsOut",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "ids",
                                  "type": "uint256[]"
                                }
                              ],
                              "name": "batchTransferGearIn",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "address",
                                  "name": "to",
                                  "type": "address"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "ids",
                                  "type": "uint256[]"
                                }
                              ],
                              "name": "batchTransferGearOut",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                }
                              ],
                              "name": "drop",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256[]",
                                  "name": "amounts",
                                  "type": "uint256[]"
                                }
                              ],
                              "name": "dropElements",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "components": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[8]",
                                      "name": "amounts",
                                      "type": "uint256[8]"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "gears",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "internalType": "struct DungeonTokenTransferer.Offer",
                                  "name": "seller",
                                  "type": "tuple"
                                },
                                {
                                  "components": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[8]",
                                      "name": "amounts",
                                      "type": "uint256[8]"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "gears",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "internalType": "struct DungeonTokenTransferer.Offer",
                                  "name": "buyer",
                                  "type": "tuple"
                                }
                              ],
                              "name": "exchange",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                }
                              ],
                              "name": "pick",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "amount",
                                  "type": "uint256"
                                }
                              ],
                              "name": "pickElement",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "contract DungeonInfoFacet",
                                  "name": "dungeon",
                                  "type": "address"
                                },
                                {
                                  "internalType": "contract Player",
                                  "name": "player",
                                  "type": "address"
                                },
                                {
                                  "internalType": "contract Gears",
                                  "name": "gears",
                                  "type": "address"
                                },
                                {
                                  "internalType": "contract Elements",
                                  "name": "elements",
                                  "type": "address"
                                },
                                {
                                  "internalType": "contract Characters",
                                  "name": "characters",
                                  "type": "address"
                                }
                              ],
                              "name": "postUpgrade",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "deadCharacterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "amount",
                                  "type": "uint256"
                                }
                              ],
                              "name": "scavengeElements",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "characterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "deadCharacterId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                }
                              ],
                              "name": "scavengeGear",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "seller",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "buyer",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "gearId",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "coins",
                                  "type": "uint256"
                                }
                              ],
                              "name": "sellGear",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "to",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "amount",
                                  "type": "uint256"
                                }
                              ],
                              "name": "subTransferElementsFrom",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            },
                            {
                              "inputs": [
                                {
                                  "internalType": "uint256",
                                  "name": "from",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "to",
                                  "type": "uint256"
                                },
                                {
                                  "internalType": "uint256",
                                  "name": "id",
                                  "type": "uint256"
                                }
                              ],
                              "name": "subTransferGearFrom",
                              "outputs": [],
                              "stateMutability": "nonpayable",
                              "type": "function"
                            }
                          ],
                          "receipt": {
                            "to": null,
                            "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                            "contractAddress": "0x53CDC363C5B9d6d6bC8da4063D189e128558F44a",
                            "transactionIndex": 0,
                            "gasUsed": "2956100",
                            "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000200000000000000000000000000000000000000040000000004004000000000000000001000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000000000000000100000",
                            "blockHash": "0x22f6fc60e58b932b0d18079209ce6caf8b7ea44acde8648ebd6ff8c69d324a34",
                            "transactionHash": "0xcb9bc5bc6741e4a1dd3da75238da3dc2515b8130996b960f4c0a81dcb3ca52b3",
                            "logs": [
                              {
                                "transactionIndex": 0,
                                "blockNumber": 2683420,
                                "transactionHash": "0xcb9bc5bc6741e4a1dd3da75238da3dc2515b8130996b960f4c0a81dcb3ca52b3",
                                "address": "0x0000000000000000000000000000000000001010",
                                "topics": [
                                  "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                                  "0x0000000000000000000000000000000000000000000000000000000000001010",
                                  "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                                  "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
                                ],
                                "data": "0x000000000000000000000000000000000000000000000000003482c9541a480000000000000000000000000000000000000000000000003944ea3d8f022daa0000000000000000000000000000000000000000000000003a3ca754197ae3c96100000000000000000000000000000000000000000000003944b5bac5ae13620000000000000000000000000000000000000000000000003a3cdbd6e2cefe1161",
                                "logIndex": 0,
                                "blockHash": "0x22f6fc60e58b932b0d18079209ce6caf8b7ea44acde8648ebd6ff8c69d324a34"
                              }
                            ],
                            "blockNumber": 2683420,
                            "cumulativeGasUsed": "2956100",
                            "status": 1,
                            "byzantium": true
                          },
                          "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
                          "args": [],
                          "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf1a37845f8726691da0257146b4cb5cb09fcab4908a9ac824bed0d14c69f0786\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xfadb089d964cfe06a8e27c6d5f22385a039f399ef01cacf019f87b2fd2a0549c\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance\\n    ) external proxied {\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        _charactersContract.transferFrom(msg.sender, address(_holder), characterId);\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(newDelegate);\\n        }\\n        _holder.enter.value(value)(msg.sender, characterId, name, class, location);\\n        _lastCharacterIds[msg.sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(msg.sender) != playerAddress) {\\n            require(uint256(_delegates[msg.sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        uint256 balanceCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        // TODO remove *10\\n        uint256 freeEnergyFee = (balanceCharge * 10) / 100;\\n        // TODO remove *10\\n        uint256 fee = balanceCharge * 10;\\n        require(energy >= freeEnergyFee + fee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + fee);\\n        _feeRecipient.send(fee);\\n        // TODO _feeRecipient as Pool\\n\\n        // TODO use Metatx instead of local private key holding fund\\n        if (msg.sender.balance < MIN_BALANCE) {\\n            uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n            if (balanceToGive >= energy) {\\n                balanceToGive = energy;\\n                energy = 0;\\n            } else {\\n                energy -= balanceToGive;\\n            }\\n\\n            if (balanceToGive > 0) {\\n                msg.sender.transfer(balanceToGive);\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refill() public payable {\\n        _refill(msg.value);\\n    }\\n\\n    function _refill(uint256 value) internal {\\n        _players[msg.sender].energy += uint128(value);\\n        emit Refill(msg.sender, _players[msg.sender].energy);\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        if (msg.value > 0) {\\n            _refill(msg.value);\\n        }\\n        _addDelegate(_delegate);\\n    }\\n\\n    function _addDelegate(address payable _delegate) public payable {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[msg.sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[msg.sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = msg.sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x1b29df1bc9d7eb406726977624a9b77b61d2cd1a4ff5b1e5a45e9378ae0e1b9c\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n}\\n\",\"keccak256\":\"0x51937d1f4fe454e2fceadab8545288a8af637783ac0f5b4b3cb5996808645dbf\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"}},\"version\":1}",
                          "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220bfab8d92ef6fa0251231a304b6fab4ab2c99e85b62bc9332daf0323bc3fcd79664736f6c63430006050033",
                          "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220bfab8d92ef6fa0251231a304b6fab4ab2c99e85b62bc9332daf0323bc3fcd79664736f6c63430006050033",
                          "execute": {
                            "methodName": "postUpgrade",
                            "args": [
                              "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                              "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                              "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                              "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                              "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                            ]
                          },
                          "history": [
                            {
                              "abi": [
                                {
                                  "anonymous": false,
                                  "inputs": [
                                    {
                                      "indexed": true,
                                      "internalType": "uint256",
                                      "name": "seller",
                                      "type": "uint256"
                                    },
                                    {
                                      "indexed": true,
                                      "internalType": "uint256",
                                      "name": "buyer",
                                      "type": "uint256"
                                    },
                                    {
                                      "components": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[8]",
                                          "name": "amounts",
                                          "type": "uint256[8]"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "gears",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "indexed": false,
                                      "internalType": "struct DungeonTokenTransferer.Offer",
                                      "name": "sale",
                                      "type": "tuple"
                                    },
                                    {
                                      "components": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[8]",
                                          "name": "amounts",
                                          "type": "uint256[8]"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "gears",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "indexed": false,
                                      "internalType": "struct DungeonTokenTransferer.Offer",
                                      "name": "price",
                                      "type": "tuple"
                                    }
                                  ],
                                  "name": "Exchange",
                                  "type": "event"
                                },
                                {
                                  "anonymous": false,
                                  "inputs": [
                                    {
                                      "indexed": true,
                                      "internalType": "uint256",
                                      "name": "seller",
                                      "type": "uint256"
                                    },
                                    {
                                      "indexed": true,
                                      "internalType": "uint256",
                                      "name": "buyer",
                                      "type": "uint256"
                                    },
                                    {
                                      "indexed": true,
                                      "internalType": "uint256",
                                      "name": "gearId",
                                      "type": "uint256"
                                    },
                                    {
                                      "indexed": false,
                                      "internalType": "uint256",
                                      "name": "price",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "GearSale",
                                  "type": "event"
                                },
                                {
                                  "inputs": [],
                                  "name": "MAX_GEARS",
                                  "outputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "",
                                      "type": "uint256"
                                    }
                                  ],
                                  "stateMutability": "view",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "amounts",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "name": "batchTransferElementsIn",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "address",
                                      "name": "to",
                                      "type": "address"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "amounts",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "name": "batchTransferElementsOut",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "ids",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "name": "batchTransferGearIn",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "address",
                                      "name": "to",
                                      "type": "address"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "ids",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "name": "batchTransferGearOut",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "drop",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256[]",
                                      "name": "amounts",
                                      "type": "uint256[]"
                                    }
                                  ],
                                  "name": "dropElements",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "components": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[8]",
                                          "name": "amounts",
                                          "type": "uint256[8]"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "gears",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "internalType": "struct DungeonTokenTransferer.Offer",
                                      "name": "seller",
                                      "type": "tuple"
                                    },
                                    {
                                      "components": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[8]",
                                          "name": "amounts",
                                          "type": "uint256[8]"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "gears",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "internalType": "struct DungeonTokenTransferer.Offer",
                                      "name": "buyer",
                                      "type": "tuple"
                                    }
                                  ],
                                  "name": "exchange",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "pick",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "amount",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "pickElement",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "contract DungeonInfoFacet",
                                      "name": "dungeon",
                                      "type": "address"
                                    },
                                    {
                                      "internalType": "contract Player",
                                      "name": "player",
                                      "type": "address"
                                    },
                                    {
                                      "internalType": "contract Gears",
                                      "name": "gears",
                                      "type": "address"
                                    },
                                    {
                                      "internalType": "contract Elements",
                                      "name": "elements",
                                      "type": "address"
                                    },
                                    {
                                      "internalType": "contract Characters",
                                      "name": "characters",
                                      "type": "address"
                                    }
                                  ],
                                  "name": "postUpgrade",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "deadCharacterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "amount",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "scavengeElements",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "characterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "deadCharacterId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "scavengeGear",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "seller",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "buyer",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "gearId",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "coins",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "sellGear",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "to",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "amount",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "subTransferElementsFrom",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                },
                                {
                                  "inputs": [
                                    {
                                      "internalType": "uint256",
                                      "name": "from",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "to",
                                      "type": "uint256"
                                    },
                                    {
                                      "internalType": "uint256",
                                      "name": "id",
                                      "type": "uint256"
                                    }
                                  ],
                                  "name": "subTransferGearFrom",
                                  "outputs": [],
                                  "stateMutability": "nonpayable",
                                  "type": "function"
                                }
                              ],
                              "receipt": {
                                "to": null,
                                "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                                "contractAddress": "0xA4Fa824Daa87552bA16E7E2EAb924A1425544c1F",
                                "transactionIndex": 1,
                                "gasUsed": "2956100",
                                "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000080000000000000000000200000000000200000000000000000000000000000000000000000000000004004000000000000000001000000000000000000000000000000100040000008000000000000000000000000000000000000000000000000000000000000100000",
                                "blockHash": "0x43f0564f280487f678c766e22fd03c596881d726a22ba099c16f263b306d2c9e",
                                "transactionHash": "0xa3fa07ffd7c4782befde82d029992bcb87d683e7390f68fc015e4928fa23520c",
                                "logs": [
                                  {
                                    "transactionIndex": 1,
                                    "blockNumber": 2681550,
                                    "transactionHash": "0xa3fa07ffd7c4782befde82d029992bcb87d683e7390f68fc015e4928fa23520c",
                                    "address": "0x0000000000000000000000000000000000001010",
                                    "topics": [
                                      "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                                      "0x0000000000000000000000000000000000000000000000000000000000001010",
                                      "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                                      "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
                                    ],
                                    "data": "0x000000000000000000000000000000000000000000000000003482c9541a4800000000000000000000000000000000000000000000000039464d6bec141cbe0000000000000000000000000000000000000000000000004d7b05bf040031d3460000000000000000000000000000000000000000000000394618e922c002760000000000000000000000000000000000000000000000004d7b3a41cd544c1b46",
                                    "logIndex": 3,
                                    "blockHash": "0x43f0564f280487f678c766e22fd03c596881d726a22ba099c16f263b306d2c9e"
                                  }
                                ],
                                "blockNumber": 2681550,
                                "cumulativeGasUsed": "3059028",
                                "status": 1,
                                "byzantium": true
                              },
                              "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
                              "args": [],
                              "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintVault(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf1a37845f8726691da0257146b4cb5cb09fcab4908a9ac824bed0d14c69f0786\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp * 5;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xa1e6437a43c5f9686778c7f0b6ea6998d623f202f8aed28f60ad4e0e442e7e3e\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance\\n    ) external proxied {\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        _charactersContract.transferFrom(msg.sender, address(_holder), characterId);\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(newDelegate);\\n        }\\n        _holder.enter.value(value)(msg.sender, characterId, name, class, location);\\n        _lastCharacterIds[msg.sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(msg.sender) != playerAddress) {\\n            require(uint256(_delegates[msg.sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        uint256 balanceCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        // TODO remove *10\\n        uint256 freeEnergyFee = (balanceCharge * 10) / 100;\\n        // TODO remove *10\\n        uint256 fee = balanceCharge * 10;\\n        require(energy >= freeEnergyFee + fee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + fee);\\n        _feeRecipient.send(fee);\\n        // TODO _feeRecipient as Pool\\n\\n        // TODO use Metatx instead of local private key holding fund\\n        if (msg.sender.balance < MIN_BALANCE) {\\n            uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n            if (balanceToGive >= energy) {\\n                balanceToGive = energy;\\n                energy = 0;\\n            } else {\\n                energy -= balanceToGive;\\n            }\\n\\n            if (balanceToGive > 0) {\\n                msg.sender.transfer(balanceToGive);\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refill() public payable {\\n        _refill(msg.value);\\n    }\\n\\n    function _refill(uint256 value) internal {\\n        _players[msg.sender].energy += uint128(value);\\n        emit Refill(msg.sender, _players[msg.sender].energy);\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        if (msg.value > 0) {\\n            _refill(msg.value);\\n        }\\n        _addDelegate(_delegate);\\n    }\\n\\n    function _addDelegate(address payable _delegate) public payable {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[msg.sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[msg.sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = msg.sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x1b29df1bc9d7eb406726977624a9b77b61d2cd1a4ff5b1e5a45e9378ae0e1b9c\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n}\\n\",\"keccak256\":\"0x51937d1f4fe454e2fceadab8545288a8af637783ac0f5b4b3cb5996808645dbf\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintVault(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        _subBalances[0][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    // TODO remove after fix\\n    function subMint(uint256 id, uint256 amount) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[0][id] += amount;\\n        emit SubTransferSingle(0, 0, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0xcd0147fbb2a8858e06cc424f06fbce16b62e08f25bf2836c252bda68e154d3a9\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"}},\"version\":1}",
                              "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea26469706673582212208380c96c4d4a50caa82e98746d37da7c851bf904727d9930fb57287185bd63a464736f6c63430006050033",
                              "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea26469706673582212208380c96c4d4a50caa82e98746d37da7c851bf904727d9930fb57287185bd63a464736f6c63430006050033",
                              "execute": {
                                "methodName": "postUpgrade",
                                "args": [
                                  "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                                  "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                                  "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                                  "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                                  "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                                ]
                              },
                              "history": [
                                {
                                  "abi": [
                                    {
                                      "anonymous": false,
                                      "inputs": [
                                        {
                                          "indexed": true,
                                          "internalType": "uint256",
                                          "name": "seller",
                                          "type": "uint256"
                                        },
                                        {
                                          "indexed": true,
                                          "internalType": "uint256",
                                          "name": "buyer",
                                          "type": "uint256"
                                        },
                                        {
                                          "components": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[8]",
                                              "name": "amounts",
                                              "type": "uint256[8]"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "gears",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "indexed": false,
                                          "internalType": "struct DungeonTokenTransferer.Offer",
                                          "name": "sale",
                                          "type": "tuple"
                                        },
                                        {
                                          "components": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[8]",
                                              "name": "amounts",
                                              "type": "uint256[8]"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "gears",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "indexed": false,
                                          "internalType": "struct DungeonTokenTransferer.Offer",
                                          "name": "price",
                                          "type": "tuple"
                                        }
                                      ],
                                      "name": "Exchange",
                                      "type": "event"
                                    },
                                    {
                                      "anonymous": false,
                                      "inputs": [
                                        {
                                          "indexed": true,
                                          "internalType": "uint256",
                                          "name": "seller",
                                          "type": "uint256"
                                        },
                                        {
                                          "indexed": true,
                                          "internalType": "uint256",
                                          "name": "buyer",
                                          "type": "uint256"
                                        },
                                        {
                                          "indexed": true,
                                          "internalType": "uint256",
                                          "name": "gearId",
                                          "type": "uint256"
                                        },
                                        {
                                          "indexed": false,
                                          "internalType": "uint256",
                                          "name": "price",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "GearSale",
                                      "type": "event"
                                    },
                                    {
                                      "inputs": [],
                                      "name": "MAX_GEARS",
                                      "outputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "",
                                          "type": "uint256"
                                        }
                                      ],
                                      "stateMutability": "view",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "amounts",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "name": "batchTransferElementsIn",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "address",
                                          "name": "to",
                                          "type": "address"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "amounts",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "name": "batchTransferElementsOut",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "ids",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "name": "batchTransferGearIn",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "address",
                                          "name": "to",
                                          "type": "address"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "ids",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "name": "batchTransferGearOut",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "drop",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256[]",
                                          "name": "amounts",
                                          "type": "uint256[]"
                                        }
                                      ],
                                      "name": "dropElements",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "components": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[8]",
                                              "name": "amounts",
                                              "type": "uint256[8]"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "gears",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "internalType": "struct DungeonTokenTransferer.Offer",
                                          "name": "seller",
                                          "type": "tuple"
                                        },
                                        {
                                          "components": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[8]",
                                              "name": "amounts",
                                              "type": "uint256[8]"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "gears",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "internalType": "struct DungeonTokenTransferer.Offer",
                                          "name": "buyer",
                                          "type": "tuple"
                                        }
                                      ],
                                      "name": "exchange",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "pick",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "amount",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "pickElement",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "contract DungeonInfoFacet",
                                          "name": "dungeon",
                                          "type": "address"
                                        },
                                        {
                                          "internalType": "contract Player",
                                          "name": "player",
                                          "type": "address"
                                        },
                                        {
                                          "internalType": "contract Gears",
                                          "name": "gears",
                                          "type": "address"
                                        },
                                        {
                                          "internalType": "contract Elements",
                                          "name": "elements",
                                          "type": "address"
                                        },
                                        {
                                          "internalType": "contract Characters",
                                          "name": "characters",
                                          "type": "address"
                                        }
                                      ],
                                      "name": "postUpgrade",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "deadCharacterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "amount",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "scavengeElements",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "characterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "deadCharacterId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "scavengeGear",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "seller",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "buyer",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "gearId",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "coins",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "sellGear",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "to",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "amount",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "subTransferElementsFrom",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    },
                                    {
                                      "inputs": [
                                        {
                                          "internalType": "uint256",
                                          "name": "from",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "to",
                                          "type": "uint256"
                                        },
                                        {
                                          "internalType": "uint256",
                                          "name": "id",
                                          "type": "uint256"
                                        }
                                      ],
                                      "name": "subTransferGearFrom",
                                      "outputs": [],
                                      "stateMutability": "nonpayable",
                                      "type": "function"
                                    }
                                  ],
                                  "receipt": {
                                    "to": null,
                                    "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                                    "contractAddress": "0x10eCc10593FA31f32A4885ee54AE008FA09B9614",
                                    "transactionIndex": 0,
                                    "gasUsed": "2956100",
                                    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000200000000000000000000000000000000000000040000000004004000000000000000001000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000000000000000100000",
                                    "blockHash": "0x55b7924b827e0d57d6d26279f9bdb1abffe2709cb822594637985056739aec9f",
                                    "transactionHash": "0xd93e8878ead4a517f8105ba2b4d3907b06b8d88571b25260e5b87b0eff3b3854",
                                    "logs": [
                                      {
                                        "transactionIndex": 0,
                                        "blockNumber": 2637964,
                                        "transactionHash": "0xd93e8878ead4a517f8105ba2b4d3907b06b8d88571b25260e5b87b0eff3b3854",
                                        "address": "0x0000000000000000000000000000000000001010",
                                        "topics": [
                                          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                                          "0x0000000000000000000000000000000000000000000000000000000000001010",
                                          "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                                          "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
                                        ],
                                        "data": "0x000000000000000000000000000000000000000000000000003482c9541a480000000000000000000000000000000000000000000000003943c9240b01ecec0000000000000000000000000000000000000000000000003937cfcd41c2c3a5ae0000000000000000000000000000000000000000000000394394a141add2a4000000000000000000000000000000000000000000000000393804500b16ddedae",
                                        "logIndex": 0,
                                        "blockHash": "0x55b7924b827e0d57d6d26279f9bdb1abffe2709cb822594637985056739aec9f"
                                      }
                                    ],
                                    "blockNumber": 2637964,
                                    "cumulativeGasUsed": "2956100",
                                    "status": 1,
                                    "byzantium": true
                                  },
                                  "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
                                  "args": [],
                                  "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, 0, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, 0, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintTo(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4050b609bae4a5415b495ccd7f4708bd888fdb1efdfba3c9158f0a8404df18c2\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x28674e489b8b36a31889c561c17dc28115c60409d267a1b6ec0ecc8ae2236099\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp * 5;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xa1e6437a43c5f9686778c7f0b6ea6998d623f202f8aed28f60ad4e0e442e7e3e\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance\\n    ) external proxied {\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        _charactersContract.transferFrom(msg.sender, address(_holder), characterId);\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(newDelegate);\\n        }\\n        _holder.enter.value(value)(msg.sender, characterId, name, class, location);\\n        _lastCharacterIds[msg.sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(msg.sender) != playerAddress) {\\n            require(uint256(_delegates[msg.sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        uint256 balanceCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        // TODO remove *10\\n        uint256 freeEnergyFee = (balanceCharge * 10) / 100;\\n        // TODO remove *10\\n        uint256 fee = balanceCharge * 10;\\n        require(energy >= freeEnergyFee + fee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + fee);\\n        _feeRecipient.send(fee);\\n        // TODO _feeRecipient as Pool\\n\\n        // TODO use Metatx instead of local private key holding fund\\n        if (msg.sender.balance < MIN_BALANCE) {\\n            uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n            if (balanceToGive >= energy) {\\n                balanceToGive = energy;\\n                energy = 0;\\n            } else {\\n                energy -= balanceToGive;\\n            }\\n\\n            if (balanceToGive > 0) {\\n                msg.sender.transfer(balanceToGive);\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refill() public payable {\\n        _refill(msg.value);\\n    }\\n\\n    function _refill(uint256 value) internal {\\n        _players[msg.sender].energy += uint128(value);\\n        emit Refill(msg.sender, _players[msg.sender].energy);\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        if (msg.value > 0) {\\n            _refill(msg.value);\\n        }\\n        _addDelegate(_delegate);\\n    }\\n\\n    function _addDelegate(address payable _delegate) public payable {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[msg.sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[msg.sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = msg.sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x1b29df1bc9d7eb406726977624a9b77b61d2cd1a4ff5b1e5a45e9378ae0e1b9c\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n}\\n\",\"keccak256\":\"0x51937d1f4fe454e2fceadab8545288a8af637783ac0f5b4b3cb5996808645dbf\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x07e039b9b9013c02d30aac5e97ba264934836bab2e8a3118819dea416a8ccb30\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"}},\"version\":1}",
                                  "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220986ba7ae11c0d8295a3cf98b4738670f4d876c19e25fd85386baa9cd055e9ba064736f6c63430006050033",
                                  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220986ba7ae11c0d8295a3cf98b4738670f4d876c19e25fd85386baa9cd055e9ba064736f6c63430006050033",
                                  "execute": {
                                    "methodName": "postUpgrade",
                                    "args": [
                                      "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                                      "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                                      "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                                      "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                                      "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                                    ]
                                  },
                                  "history": [
                                    {
                                      "abi": [
                                        {
                                          "anonymous": false,
                                          "inputs": [
                                            {
                                              "indexed": true,
                                              "internalType": "uint256",
                                              "name": "seller",
                                              "type": "uint256"
                                            },
                                            {
                                              "indexed": true,
                                              "internalType": "uint256",
                                              "name": "buyer",
                                              "type": "uint256"
                                            },
                                            {
                                              "components": [
                                                {
                                                  "internalType": "uint256",
                                                  "name": "characterId",
                                                  "type": "uint256"
                                                },
                                                {
                                                  "internalType": "uint256[8]",
                                                  "name": "amounts",
                                                  "type": "uint256[8]"
                                                },
                                                {
                                                  "internalType": "uint256[]",
                                                  "name": "gears",
                                                  "type": "uint256[]"
                                                }
                                              ],
                                              "indexed": false,
                                              "internalType": "struct DungeonTokenTransferer.Offer",
                                              "name": "sale",
                                              "type": "tuple"
                                            },
                                            {
                                              "components": [
                                                {
                                                  "internalType": "uint256",
                                                  "name": "characterId",
                                                  "type": "uint256"
                                                },
                                                {
                                                  "internalType": "uint256[8]",
                                                  "name": "amounts",
                                                  "type": "uint256[8]"
                                                },
                                                {
                                                  "internalType": "uint256[]",
                                                  "name": "gears",
                                                  "type": "uint256[]"
                                                }
                                              ],
                                              "indexed": false,
                                              "internalType": "struct DungeonTokenTransferer.Offer",
                                              "name": "price",
                                              "type": "tuple"
                                            }
                                          ],
                                          "name": "Exchange",
                                          "type": "event"
                                        },
                                        {
                                          "anonymous": false,
                                          "inputs": [
                                            {
                                              "indexed": true,
                                              "internalType": "uint256",
                                              "name": "seller",
                                              "type": "uint256"
                                            },
                                            {
                                              "indexed": true,
                                              "internalType": "uint256",
                                              "name": "buyer",
                                              "type": "uint256"
                                            },
                                            {
                                              "indexed": true,
                                              "internalType": "uint256",
                                              "name": "gearId",
                                              "type": "uint256"
                                            },
                                            {
                                              "indexed": false,
                                              "internalType": "uint256",
                                              "name": "price",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "GearSale",
                                          "type": "event"
                                        },
                                        {
                                          "inputs": [],
                                          "name": "MAX_GEARS",
                                          "outputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "",
                                              "type": "uint256"
                                            }
                                          ],
                                          "stateMutability": "view",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "amounts",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "name": "batchTransferElementsIn",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "address",
                                              "name": "to",
                                              "type": "address"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "amounts",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "name": "batchTransferElementsOut",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "ids",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "name": "batchTransferGearIn",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "address",
                                              "name": "to",
                                              "type": "address"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "ids",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "name": "batchTransferGearOut",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "drop",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256[]",
                                              "name": "amounts",
                                              "type": "uint256[]"
                                            }
                                          ],
                                          "name": "dropElements",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "components": [
                                                {
                                                  "internalType": "uint256",
                                                  "name": "characterId",
                                                  "type": "uint256"
                                                },
                                                {
                                                  "internalType": "uint256[8]",
                                                  "name": "amounts",
                                                  "type": "uint256[8]"
                                                },
                                                {
                                                  "internalType": "uint256[]",
                                                  "name": "gears",
                                                  "type": "uint256[]"
                                                }
                                              ],
                                              "internalType": "struct DungeonTokenTransferer.Offer",
                                              "name": "seller",
                                              "type": "tuple"
                                            },
                                            {
                                              "components": [
                                                {
                                                  "internalType": "uint256",
                                                  "name": "characterId",
                                                  "type": "uint256"
                                                },
                                                {
                                                  "internalType": "uint256[8]",
                                                  "name": "amounts",
                                                  "type": "uint256[8]"
                                                },
                                                {
                                                  "internalType": "uint256[]",
                                                  "name": "gears",
                                                  "type": "uint256[]"
                                                }
                                              ],
                                              "internalType": "struct DungeonTokenTransferer.Offer",
                                              "name": "buyer",
                                              "type": "tuple"
                                            }
                                          ],
                                          "name": "exchange",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "pick",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "amount",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "pickElement",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "contract DungeonInfoFacet",
                                              "name": "dungeon",
                                              "type": "address"
                                            },
                                            {
                                              "internalType": "contract Player",
                                              "name": "player",
                                              "type": "address"
                                            },
                                            {
                                              "internalType": "contract Gears",
                                              "name": "gears",
                                              "type": "address"
                                            },
                                            {
                                              "internalType": "contract Elements",
                                              "name": "elements",
                                              "type": "address"
                                            },
                                            {
                                              "internalType": "contract Characters",
                                              "name": "characters",
                                              "type": "address"
                                            }
                                          ],
                                          "name": "postUpgrade",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "deadCharacterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "amount",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "scavengeElements",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "characterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "deadCharacterId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "scavengeGear",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "seller",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "buyer",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "gearId",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "coins",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "sellGear",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "to",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "amount",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "subTransferElementsFrom",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        },
                                        {
                                          "inputs": [
                                            {
                                              "internalType": "uint256",
                                              "name": "from",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "to",
                                              "type": "uint256"
                                            },
                                            {
                                              "internalType": "uint256",
                                              "name": "id",
                                              "type": "uint256"
                                            }
                                          ],
                                          "name": "subTransferGearFrom",
                                          "outputs": [],
                                          "stateMutability": "nonpayable",
                                          "type": "function"
                                        }
                                      ],
                                      "receipt": {
                                        "to": null,
                                        "from": "0xC92aE171cb9AEfEbcB88cdB40ba508e81F30AE1b",
                                        "contractAddress": "0xe3B07B8968e47C4a980eAD8808077e4171f35168",
                                        "transactionIndex": 0,
                                        "gasUsed": "2956100",
                                        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000200000000000000000000000000000000000000040000000004004000000000000000001000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000000000000000100000",
                                        "blockHash": "0xf351c100bd02c64d75545b7f01c64ed8e52c1a713d2422b170d258226ef8c372",
                                        "transactionHash": "0xd0d69a0a4b426d0a53dfaf1200d7efa0c6868a42c2c0608f15fe56181db723b0",
                                        "logs": [
                                          {
                                            "transactionIndex": 0,
                                            "blockNumber": 2628892,
                                            "transactionHash": "0xd0d69a0a4b426d0a53dfaf1200d7efa0c6868a42c2c0608f15fe56181db723b0",
                                            "address": "0x0000000000000000000000000000000000001010",
                                            "topics": [
                                              "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
                                              "0x0000000000000000000000000000000000000000000000000000000000001010",
                                              "0x000000000000000000000000c92ae171cb9aefebcb88cdb40ba508e81f30ae1b",
                                              "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
                                            ],
                                            "data": "0x000000000000000000000000000000000000000000000000003482c9541a4800000000000000000000000000000000000000000000000003086c599f26a74e00000000000000000000000000000000000000000000000039356c7db656d5efae0000000000000000000000000000000000000000000000030837d6d5d28d060000000000000000000000000000000000000000000000003935a1007faaf037ae",
                                            "logIndex": 0,
                                            "blockHash": "0xf351c100bd02c64d75545b7f01c64ed8e52c1a713d2422b170d258226ef8c372"
                                          }
                                        ],
                                        "blockNumber": 2628892,
                                        "cumulativeGasUsed": "2956100",
                                        "status": 1,
                                        "byzantium": true
                                      },
                                      "address": "0x43b0EfA811E7be03ba67454c203144FFc6Ae668b",
                                      "args": [],
                                      "metadata": "{\"compiler\":{\"version\":\"0.6.5+commit.f956cc89\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GearSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_GEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferElementsOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferGearOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"dropElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"seller\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"amounts\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"gears\",\"type\":\"uint256[]\"}],\"internalType\":\"struct DungeonTokenTransferer.Offer\",\"name\":\"buyer\",\"type\":\"tuple\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pickElement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DungeonInfoFacet\",\"name\":\"dungeon\",\"type\":\"address\"},{\"internalType\":\"contract Player\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract Gears\",\"name\":\"gears\",\"type\":\"address\"},{\"internalType\":\"contract Elements\",\"name\":\"elements\",\"type\":\"address\"},{\"internalType\":\"contract Characters\",\"name\":\"characters\",\"type\":\"address\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scavengeElements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadCharacterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"scavengeGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gearId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coins\",\"type\":\"uint256\"}],\"name\":\"sellGear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subTransferElementsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"subTransferGearFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"src/dungeon/DungeonTokenTransferer.sol\":\"DungeonTokenTransferer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"buidler-deploy/solc_0.6/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nabstract contract Proxied {\\n    modifier proxied() {\\n        address adminAddress;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n        if (adminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == adminAddress);\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x7a52615923f87f723441805ffcd8f9e99625ae77ceed130c86f08a2e34970787\"},\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\":{\"content\":\"pragma solidity ^0.6.4;\\n\\n// * from https://github.com/mudgen/Diamond/blob/8235e6b63b47aab08a81c6f73bfb7faafda79ca4/contracts/\\n\\n// modified to be an abstract\\n\\nabstract contract DiamondStorageContract {\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to the slot in the selectorSlots array.\\n        // and maps the selectors to the position in the slot.\\n        // func selector => address facet, uint64 slotsIndex, uint64 slotIndex\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // uint128 numSelectorsInSlot, uint128 selectorSlotsLength\\n        // selectorSlotsLength is the number of 32-byte slots in selectorSlots.\\n        // selectorSlotLength is the number of selectors in the last slot of\\n        // selectorSlots.\\n        uint256 selectorSlotsLength;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        // ds_slot = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n        assembly {\\n            ds_slot := 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ddce9c68aba45af0b56b560e6cb369bf53f5c08a25bd4b55ed522aae1c233ee\"},\"src/characters/Characters.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./CharactersDataLayout.sol\\\";\\n\\ncontract Characters is Proxied, CharactersDataLayout {\\n    event CharacterUpdate(uint256 indexed id, address indexed owner, uint256 data);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    function postUpgrade() external proxied {\\n        if (nextId == 0) {\\n            nextId = 1;\\n        }\\n    }\\n\\n    function getSubOwner(uint256 id) external view returns (uint256) {\\n        return _subOwner[id][_owners[id]];\\n    }\\n\\n    function setSubOwner(uint256 id, uint256 subOwner) external {\\n        require(msg.sender == _owners[id], \\\"only owner is able to set sub owner\\\");\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n    }\\n\\n    function _setSubOwnerFor(\\n        uint256 id,\\n        address owner,\\n        uint256 subOwner\\n    ) internal {\\n        // TODO emit SubOwnerTransferEvent\\n        _subOwner[id][owner] = subOwner;\\n    }\\n\\n    function mintTo(address to) external returns (uint256) {\\n        return _mint(to);\\n    }\\n\\n    // subowner is uint(address) of player currently\\n    // when subowner == 0 character is considered not in the dungeon\\n    function mint(uint256 subOwner) external returns (uint256) {\\n        uint256 id = _mint(msg.sender);\\n        _setSubOwnerFor(id, msg.sender, subOwner);\\n        return id;\\n    }\\n\\n    function _mint(address to) internal returns (uint256) {\\n        uint256 id = nextId++;\\n        _owners[id] = to;\\n        _numPerOwners[to]++;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id][msg.sender];\\n    }\\n\\n    function getDataFor(uint256 id, address owner) external view returns (uint256) {\\n        return _data[id][owner];\\n    }\\n\\n    // TODO only dungeon should be able to set data\\n    // currently this can be called by the player when characters is outside of dungeon\\n    function setData(uint256 id, uint256 data) external {\\n        require(msg.sender == _ownerOf(id), \\\"only owner is allowed to set data\\\");\\n        _setDataFor(id, msg.sender, data);\\n    }\\n\\n    function _setDataFor(\\n        uint256 id,\\n        address owner,\\n        uint256 data\\n    ) internal {\\n        _data[id][owner] = data;\\n        emit CharacterUpdate(id, owner, data);\\n    }\\n\\n    function _ownerOf(uint256 id) internal view returns (address) {\\n        return _owners[id];\\n    }\\n\\n    function fullOwnerOf(uint256 id) external view returns (address owner, uint256 subOwner) {\\n        owner = _ownerOf(id);\\n        subOwner = _subOwner[id][owner];\\n    }\\n\\n    // EIP-721 Standard\\n    function ownerOf(uint256 id) external view returns (address tokenOwner) {\\n        tokenOwner = _ownerOf(id);\\n        require(tokenOwner != address(0), \\\"token does not exist\\\");\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _numPerOwners[who];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(from != address(0), \\\"from is zero address\\\");\\n        require(to != address(0), \\\"from is zero address\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"from is not owner\\\");\\n        _subOwner[id][owner] = 0;\\n        _owners[id] = to;\\n        _numPerOwners[from]--;\\n        _numPerOwners[to]++;\\n    }\\n\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\n        // TODO metadata || id == 0x5b5e139f;\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n}\\n\",\"keccak256\":\"0xdf591bd894e7d3c85ff5e211ff6bc8b7f5d92ad62871062e73696445f0b5042e\"},\"src/characters/CharactersDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract CharactersDataLayout {\\n    uint256 nextId;\\n    mapping(uint256 => address) _owners;\\n    mapping(address => uint256) _numPerOwners;\\n    mapping(uint256 => mapping(address => uint256)) _subOwner;\\n    mapping(uint256 => mapping(address => uint256)) _data;\\n}\\n\",\"keccak256\":\"0x07af58bd3f1cbde1a9e87e11f65505da0ef1377f26a9b41cee4750ffd0c9b894\"},\"src/dungeon/DungeonDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../tokens/Rooms.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonDataLayout {\\n    struct Room {\\n        uint64 blockNumber;\\n        uint64 monsterBlockNumber;\\n        uint64 numActiveCharacters;\\n        uint8 direction;\\n        uint8 exits;\\n        uint8 kind;\\n        uint8 areaAtDiscovery;\\n        uint8 lastRoomIndex;\\n        uint8 index;\\n        uint256 discoverer;\\n        uint64 randomEvent;\\n    }\\n\\n    struct Character {\\n        uint256 location;\\n        uint8 direction;\\n        int64 floors;\\n        uint256 slot_1; // attack // TODO store this on character NFT ?\\n        uint256 slot_2; // defense // TODO store this on character NFT ?\\n        uint256 slot_3; // accessory 1 // TODO store this on character NFT ?\\n        uint256 slot_4; // accessory 2 // TODO store this on character NFT ?5\\n        uint256 slot_5; // accessory 3 // TODO store this on character NFT ?\\n    }\\n\\n    struct Area {\\n        uint8 areaType;\\n        uint8 discovered; // record room types already discovered : temple, teleport ...\\n        uint8 lastRoomIndex; // track what was the index of the room discovered first in last block\\n        uint8 currentIndex; // track the index of room discovered in the same block\\n        uint256 lastRoom; // last room disovered in a block, used for area blockHash too\\n        uint64 eventBlockNumber;\\n    }\\n\\n    mapping(uint256 => Character) _characters;\\n    mapping(uint256 => Room) _rooms;\\n    mapping(uint256 => Area) _areas;\\n\\n    struct AreaCounter {\\n        uint64 lastPeriod;\\n        uint64 numAreas;\\n    }\\n    AreaCounter _areaCounter;\\n\\n    address _adminContract;\\n    BlockHashRegister _blockHashRegister;\\n    Characters _charactersContract;\\n    Elements _elementsContract;\\n    Gears _gearsContract;\\n    Rooms _roomsContract;\\n    Player _playerContract;\\n\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => bool))) _unlockedExits;\\n\\n    struct Quest {\\n        uint8 status;\\n        string data;\\n    }\\n    mapping(uint256 => mapping(uint64 => Quest)) _quests; // _quests[character][id]\\n\\n    mapping(address => uint256) _taxDueDate;\\n\\n    mapping(uint256 => string) _customRoomNames;\\n}\\n\",\"keccak256\":\"0x9d189dba696ee5710f0cbb5c36e2ad3e3ac251c3263e1739c0e0c60772496c5e\"},\"src/dungeon/DungeonEvents.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract DungeonEvents {\\n    event RoomDiscovered(uint256 indexed location, uint64 blockNumber, uint8 direction);\\n    event RoomActualised(uint256 indexed location, bytes32 blockHash, uint8 exits, uint8 kind);\\n    event CharacterMoved(\\n        uint256 indexed characterId,\\n        uint256 indexed oldLocation,\\n        uint256 indexed newLocation,\\n        uint8 mode,\\n        uint256 path\\n    );\\n    event Enter(uint256 indexed characterId, address indexed player, string name);\\n    event Death(uint256 indexed characterId, uint256 monsterId);\\n    event LevelUp(uint256 indexed characterId, uint16 newLevel);\\n    event Equip(uint256 characterId, uint256 gearId, uint8 slotType);\\n    event Resurrect(uint256 indexed deadCharacterId, uint256 newCharacterId);\\n    event Heal(uint256 indexed characterId, uint16 hp);\\n    event RandomEvent(uint256 indexed areaLocation, uint64 blockNumber);\\n    event Recycle(uint256 indexed characterId, uint256 gearId);\\n    event QuestUpdate(uint256 indexed characterId, uint64 indexed id, uint8 indexed status, string data);\\n    event RoomTaxPay(address indexed owner, uint256 tax, uint256 newDueDate);\\n    event RoomIncome(uint256 indexed location, address indexed owner, uint256 id, uint256 amount);\\n    event RoomName(uint256 indexed location, string name, uint256 characterId);\\n}\\n\",\"keccak256\":\"0xe737adf71af0dc8563dbe62e7be657100e28ca7cfd81f5730c3ea14d666b9712\"},\"src/dungeon/DungeonFacetBase.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/diamond/DiamondStorageContract.sol\\\";\\nimport \\\"./DungeonDataLayout.sol\\\";\\nimport \\\"./DungeonEvents.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\nabstract contract DungeonFacetBase is DungeonDataLayout, DungeonEvents, DiamondStorageContract {\\n    uint256 internal constant MAX_GEARS = 10;\\n\\n    modifier onlyOwner() {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _adminContract, \\\"NOT_AUTHORIZED_ADMIN\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_playerContract), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        Room storage room = _rooms[location];\\n        require(room.blockNumber > 0, \\\"room not created yet\\\");\\n        if (room.kind == 0) {\\n            bytes32 blockHash = _blockHashRegister.get(room.blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            _actualiseArea(location, blockHash);\\n            (uint8 exits, uint8 kind, uint8 area_discovered) = PureDungeon._generateRoom(\\n                location,\\n                blockHash,\\n                room.direction,\\n                room.areaAtDiscovery,\\n                room.lastRoomIndex,\\n                room.index\\n            );\\n            room.exits = exits;\\n            room.kind = kind;\\n            uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n            Area storage area = _areas[areaLoc];\\n            if (area.discovered != area_discovered) {\\n                area.discovered = area_discovered;\\n            }\\n            emit RoomActualised(location, blockHash, exits, kind);\\n            uint8 areaType = _areas[areaLoc].areaType;\\n            if (room.discoverer != 0) {\\n                CharacterData memory characterData = _getCharacterData(room.discoverer);\\n                (uint256 numGold, uint256 numElements) = PureDungeon._computeRoomDiscoveryReward(\\n                    location,\\n                    blockHash,\\n                    characterData.class\\n                );\\n                if (areaType <= 5) {\\n                    _elementsContract.mint(room.discoverer, areaType, numElements);\\n                }\\n                _elementsContract.mint(room.discoverer, 6, numGold);\\n            }\\n        }\\n        _actualiseRandomEvent(PureDungeon._getAreaLoc(location)); // room actualisation take precedence // monster\\n    }\\n\\n    function _actualiseArea(uint256 location, bytes32 blockHash) internal {\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        uint8 areaType = _areas[areaLoc].areaType;\\n        if (areaType == 0) {\\n            uint64 currentNumAreas = _areaCounter.numAreas;\\n            areaType = PureDungeon._generateArea(areaLoc, blockHash, currentNumAreas);\\n            _areas[areaLoc].areaType = areaType;\\n            if (areaType != 6) {\\n                uint64 period = uint64(block.timestamp / 23 hours);\\n                if (_areaCounter.lastPeriod != period) {\\n                    _areaCounter.lastPeriod = period;\\n                    _areaCounter.numAreas = 1;\\n                } else {\\n                    _areaCounter.numAreas = currentNumAreas + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    struct CharacterData {\\n        uint8 class;\\n        uint16 level;\\n        uint32 xp;\\n        uint16 maxHP;\\n        uint16 hp;\\n    }\\n\\n    function _setCharacterData(uint256 characterId, CharacterData memory characterData) internal {\\n        uint256 data = ((uint256(characterData.class) << 248) +\\n            (uint256(characterData.level) << 232) +\\n            (uint256(characterData.xp) << 200) +\\n            (uint256(characterData.maxHP) << 184) +\\n            (uint256(characterData.hp) << 168));\\n        _charactersContract.setData(characterId, data);\\n    }\\n\\n    function _getCharacterData(uint256 characterId) internal view returns (CharacterData memory) {\\n        uint256 data = _charactersContract.getData(characterId);\\n        (uint16 level, uint16 hp, uint16 maxHP, uint32 xp, uint8 class) = PureDungeon._decodeCharacterData(data);\\n        return CharacterData(class, level, xp, maxHP, hp);\\n    }\\n\\n    function _actualiseRandomEvent(uint256 areaLoc) internal {\\n        Area storage area = _areas[areaLoc];\\n        uint64 blockNumber = area.eventBlockNumber;\\n        if (blockNumber != 0) {\\n            bytes32 blockHash = _blockHashRegister.get(blockNumber);\\n            if (blockHash == 0) {\\n                // skip as block is not actualised or not in register\\n                return;\\n            }\\n            (uint256 roomLocation, uint64 randomEvent) = PureDungeon._generateRandomEvent(areaLoc, blockHash);\\n            uint256 monsterIndex = _checkMonsterBlockNumber(roomLocation);\\n            Room storage room = _rooms[roomLocation];\\n            if (room.randomEvent == 0 && room.numActiveCharacters == 0 && monsterIndex == 0 && room.kind != 0) {\\n                room.randomEvent = randomEvent;\\n            }\\n            area.eventBlockNumber = 0;\\n        }\\n    }\\n\\n    /// @dev to be valid it require the room to be actualised first\\n    function _checkMonster(uint256 location) internal view returns (uint256) {\\n        uint256 monsterIndex = _checkMonsterBlockNumber(location);\\n        // if (monsterIndex == 0) {\\n        //     if (_roomEvents[location] == 1)  { //TODO monster indicator\\n        //         return 1;\\n        //     }\\n        //     return 0;\\n        // }\\n        return monsterIndex;\\n    }\\n\\n    function _checkMonsterBlockNumber(uint256 location) internal view returns (uint256) {\\n        uint64 monsterBlockNumber = _rooms[location].monsterBlockNumber;\\n        if (monsterBlockNumber == 0) {\\n            // no monsters\\n            return 0;\\n        }\\n        bytes32 monsterBlockHash = _blockHashRegister.get(monsterBlockNumber);\\n        if (monsterBlockHash == 0) {\\n            // skip as monster block is not actualised\\n            return 0;\\n        }\\n        bool newlyDiscoveredRoom = monsterBlockNumber == _rooms[location].blockNumber;\\n        return\\n            PureDungeon._generateMonsterIndex(\\n                location,\\n                monsterBlockHash,\\n                1,\\n                newlyDiscoveredRoom,\\n                _rooms[location].kind\\n            );\\n    }\\n\\n    struct GearData {\\n        uint16 level;\\n        uint8 slot;\\n        uint8 classBits; // bit array of allowed classes indexed by lsb\\n        uint16 durability;\\n        uint16 maxDurability; // gear is unbreakable when maxDurablity is 0\\n        uint32 template;\\n    }\\n\\n    function _setGearData(uint256 gearId, GearData memory gear) internal {\\n        uint256 data = PureDungeon._encodeGearData(\\n            gear.level,\\n            gear.slot,\\n            gear.classBits,\\n            gear.durability,\\n            gear.maxDurability,\\n            gear.template\\n        );\\n        _gearsContract.setData(gearId, data);\\n    }\\n\\n    function _getGearData(uint256 gearId) internal view returns (GearData memory) {\\n        uint256 data = _gearsContract.getData(gearId);\\n        (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        ) = PureDungeon._decodeGearData(data);\\n        return GearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _addInitialGears(uint256 characterId, uint16 level) internal {\\n        uint256 attackGearData = PureDungeon._encodeGearData(0, 0, 15, 10, 10, 1);\\n        uint256 defenseGearData = PureDungeon._encodeGearData(0, 1, 15, 10, 10, 4);\\n        uint256 attackGear = _gearsContract.mint(characterId, attackGearData);\\n        _equip(characterId, level, 0, attackGear, 0);\\n        uint256 defenseGear = _gearsContract.mint(characterId, defenseGearData);\\n        _equip(characterId, level, 0, defenseGear, 1);\\n    }\\n\\n    // TODO restrict transfer of equiped items\\n    function _equip(\\n        uint256 characterId,\\n        uint16 level,\\n        uint8 class,\\n        uint256 id,\\n        uint8 slot\\n    ) internal {\\n        GearData memory gear = _getGearData(id);\\n        require(gear.level <= level, \\\"gear Level too high\\\");\\n        require((gear.classBits >> class) & 1 != 0, \\\"invalid class\\\");\\n        if (slot == 0) {\\n            require(gear.slot == 0, \\\"only attack gear on slot 0\\\");\\n            _characters[characterId].slot_1 = id;\\n        } else if (slot == 1) {\\n            require(gear.slot == 1, \\\"only defense gear on slot 1\\\");\\n            _characters[characterId].slot_2 = id;\\n        } else if (slot == 2) {\\n            require(gear.slot == 2, \\\"only accessories on slot 2\\\");\\n            _characters[characterId].slot_3 = id;\\n        } else if (slot == 3) {\\n            require(gear.slot == 2, \\\"only accessories on slot 3\\\");\\n            _characters[characterId].slot_4 = id;\\n        } else if (slot == 4) {\\n            require(gear.slot == 2, \\\"only accessories on slot 4\\\");\\n            _characters[characterId].slot_5 = id;\\n        }\\n        emit Equip(characterId, id, gear.slot);\\n    }\\n\\n    function _handleKey(\\n        uint256 characterId,\\n        uint256 location,\\n        uint256 location2\\n    ) internal {\\n        uint256 location1 = location;\\n        if (location1 > location2) {\\n            location1 = location2;\\n            location2 = location;\\n        }\\n        if (!_isUnlocked(characterId, location1, location2)) {\\n            require(_elementsContract.subBalanceOf(characterId, PureDungeon.KEYS) > 0, \\\"no key\\\");\\n            _elementsContract.subBurnFrom(characterId, PureDungeon.KEYS, 1);\\n            _unlockedExits[characterId][location1][location2] = true;\\n        }\\n    }\\n\\n    function _isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) internal view returns (bool) {\\n        return _unlockedExits[characterId][location1][location2];\\n    }\\n\\n    function _getAreaTypeForRoom(uint256 location) internal view returns (uint8) {\\n        return _areas[PureDungeon._getAreaLoc(location)].areaType;\\n    }\\n\\n    function _moveTo(\\n        uint256 characterId,\\n        uint256 oldLocation,\\n        uint8 direction\\n    ) internal returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = PureDungeon._coordinates(oldLocation);\\n        if (PureDungeon.NORTH == direction) {\\n            y--;\\n        } else if (PureDungeon.EAST == direction) {\\n            x++;\\n        } else if (PureDungeon.SOUTH == direction) {\\n            y++;\\n        } else if (PureDungeon.WEST == direction) {\\n            x--;\\n        } else {\\n            revert(\\\"impossible direction\\\");\\n        }\\n        uint256 newLocation = PureDungeon._location(x, y, z);\\n        Room storage currentRoom = _rooms[oldLocation];\\n        Room storage nextRoom = _rooms[newLocation];\\n        uint64 cb = currentRoom.blockNumber;\\n        uint64 nb = nextRoom.blockNumber;\\n        uint8 exitMask = uint8(2)**direction;\\n        uint8 opositeExitMask = uint8(2)**((direction + 2) % 4);\\n        if (cb < nb || nb == 0) {\\n            if ((currentRoom.exits & exitMask) == exitMask) {\\n                if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else if (cb > nb) {\\n            if ((nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                    _handleKey(characterId, oldLocation, newLocation);\\n                }\\n                return newLocation;\\n            }\\n        } else {\\n            if ((currentRoom.exits & exitMask) == exitMask || (nextRoom.exits & opositeExitMask) == opositeExitMask) {\\n                if (oldLocation > newLocation) {\\n                    if ((nextRoom.exits / 2**4) & opositeExitMask == opositeExitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                } else {\\n                    if ((currentRoom.exits / 2**4) & exitMask == exitMask) {\\n                        _handleKey(characterId, oldLocation, newLocation);\\n                    }\\n                }\\n                return newLocation;\\n            }\\n        }\\n        revert(\\\"cant move this way\\\");\\n    }\\n\\n    function _move(\\n        uint256 characterId,\\n        uint256 location,\\n        uint8 direction\\n    ) internal {\\n        Character storage character = _characters[characterId];\\n        Room storage currentRoom = _rooms[character.location];\\n        Room storage nextRoom = _rooms[location];\\n        uint64 blockNumber;\\n        if (nextRoom.blockNumber == 0) {\\n            _discoverRoom(location, characterId, direction);\\n        } else {\\n            // TODO should we actualiseRoom first, before monster ?\\n            if (nextRoom.monsterBlockNumber == 0 && nextRoom.numActiveCharacters == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n                if (nextRoom.monsterBlockNumber == 0) {\\n                    nextRoom.monsterBlockNumber = blockNumber;\\n                }\\n            }\\n            _actualiseRoom(location);\\n            address benefactor = _roomBenefactor(location);\\n            if (benefactor != address(0) && uint256(benefactor) != _charactersContract.getSubOwner(characterId)) {\\n                _elementsContract.mintTo(benefactor, PureDungeon.FRAGMENTS, 1);\\n                emit RoomIncome(location, benefactor, PureDungeon.FRAGMENTS, 1);\\n            }\\n        }\\n        uint256 areaLoc = PureDungeon._getAreaLoc(location);\\n        Area storage area = _areas[areaLoc];\\n        if (area.eventBlockNumber == 0 && block.number % 3 == 0) {\\n            if (blockNumber == 0) {\\n                blockNumber = uint64(block.number);\\n                _blockHashRegister.request();\\n            }\\n            area.eventBlockNumber = blockNumber;\\n            emit RandomEvent(areaLoc, blockNumber);\\n        }\\n        currentRoom.numActiveCharacters--;\\n        nextRoom.numActiveCharacters++;\\n        character.location = location;\\n        character.direction = direction;\\n        _increaseHPXP(characterId);\\n    }\\n\\n    function _increaseHPXP(uint256 characterId) internal {\\n        CharacterData memory characterData = _getCharacterData(characterId);\\n        if (characterData.hp < characterData.maxHP) {\\n            characterData.hp += 1;\\n            _setCharacterData(characterId, characterData);\\n        }\\n    }\\n\\n    function _isRoomActive(uint256 location) internal view returns (bool) {\\n        address owner = _roomsContract.ownerOf(location);\\n        return owner == address(this);\\n    }\\n\\n    function _roomBenefactor(uint256 location) internal view returns (address){\\n        if (_isRoomActive(location)) {\\n            return address(_roomsContract.subOwnerOf(location));\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function _pay(uint256 characterId, uint256 location, uint256 id, uint256 amount) internal {\\n        address benefactor = _roomBenefactor(location);\\n        if (benefactor != address(0)) {\\n            uint256 share = amount / 5;\\n            if (share > 0) {\\n                _elementsContract.subTransferFrom(characterId, 0, id, share);\\n                _elementsContract.transferFrom(address(this), benefactor, id, share);\\n                emit RoomIncome(location, benefactor, id, share);\\n            }\\n            _elementsContract.subBurnFrom(characterId, id, amount - share);\\n        } else {\\n            _elementsContract.subBurnFrom(characterId, id, amount);\\n        }\\n    }\\n\\n    function _discoverRoom(\\n        uint256 location,\\n        uint256 discoverer,\\n        uint8 direction\\n    ) internal {\\n        Area storage area = _areas[PureDungeon._getAreaLoc(location)];\\n        if (area.lastRoom > 0) {\\n            // area is also actualised with room when necessary\\n            _actualiseRoom(area.lastRoom);\\n            area.lastRoomIndex = area.currentIndex;\\n            area.lastRoom = 0;\\n        }\\n        _elementsContract.subBurnFrom(discoverer, PureDungeon.FRAGMENTS, PureDungeon._discoveryCost(location));\\n        Room storage nextRoom = _rooms[location];\\n        nextRoom.blockNumber = uint64(block.number);\\n        nextRoom.monsterBlockNumber = uint64(block.number);\\n        nextRoom.direction = direction;\\n        nextRoom.areaAtDiscovery = area.discovered;\\n        nextRoom.index = area.currentIndex++;\\n        nextRoom.lastRoomIndex = area.lastRoomIndex;\\n        nextRoom.discoverer = discoverer;\\n        area.lastRoom = location;\\n        _blockHashRegister.request();\\n        uint256 discovererOwner = _charactersContract.getSubOwner(discoverer);\\n        _initializeTaxDueDate(discovererOwner);\\n        _roomsContract.mintId(location, discovererOwner);\\n        emit RoomDiscovered(location, uint64(block.number), nextRoom.direction);\\n    }\\n\\n    function _initializeTaxDueDate(uint256 owner) internal {\\n        if (owner != 0 && _roomsContract.subBalanceOf(owner) == 0) {\\n            uint256 dueDate = block.timestamp + 5 days;\\n            _taxDueDate[address(owner)] = dueDate;\\n            emit RoomTaxPay(address(owner), 0, dueDate);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8ff41e9d7dd9fc49bbf451f976cff93c9947440137698c27d154c24031a5b7f2\"},\"src/dungeon/DungeonInfoFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonInfoFacet is DungeonFacetBase {\\n    function isUnlocked(\\n        uint256 characterId,\\n        uint256 location1,\\n        uint256 location2\\n    ) external view returns (bool) {\\n        return _isUnlocked(characterId, location1, location2);\\n    }\\n\\n    function getAreaTypeForRoom(uint256 location) external view returns (uint8) {\\n        return _getAreaTypeForRoom(location);\\n    }\\n\\n    function getCharacterLocation(uint256 characterId) external view returns (uint256 location) {\\n        location = _characters[characterId].location;\\n    }\\n\\n    function getCharacterInfo(uint256 characterId)\\n        external\\n        view\\n        returns (\\n            uint256 location,\\n            uint8 direction,\\n            uint256 data,\\n            uint256 attackGear,\\n            uint256 defenseGear,\\n            uint256 accessory1,\\n            uint256 accessory2,\\n            uint256 accessory3,\\n            int64 floors,\\n            uint256 taxDueDate,\\n            address player\\n        )\\n    {\\n        Character storage character = _characters[characterId];\\n        location = character.location;\\n        direction = character.direction;\\n        data = _charactersContract.getData(characterId);\\n        attackGear = character.slot_1;\\n        defenseGear = character.slot_2;\\n        accessory1 = character.slot_3;\\n        accessory2 = character.slot_4;\\n        accessory3 = character.slot_5;\\n        floors = character.floors;\\n        player = address(_charactersContract.getSubOwner(characterId));\\n        taxDueDate = _taxDueDate[player];\\n    }\\n\\n    function getRoomInfo(uint256 location)\\n        external\\n        view\\n        returns (\\n            uint256 blockNumber,\\n            uint256 monsterBlockNumber,\\n            uint8 direction,\\n            uint8 areaAtDiscovery,\\n            uint8 lastRoomIndex,\\n            uint8 index,\\n            bool actualised,\\n            uint64 numActiveCharacters,\\n            uint8 kind,\\n            uint64 randomEvent,\\n            uint256 discoverer\\n        )\\n    {\\n        Room storage room = _rooms[location];\\n        blockNumber = room.blockNumber;\\n        monsterBlockNumber = room.monsterBlockNumber;\\n        direction = room.direction;\\n        areaAtDiscovery = room.areaAtDiscovery;\\n        lastRoomIndex = room.lastRoomIndex;\\n        index = room.index;\\n        numActiveCharacters = room.numActiveCharacters;\\n        kind = room.kind;\\n        actualised = kind != 0;\\n        randomEvent = room.randomEvent;\\n        discoverer = room.discoverer;\\n    }\\n\\n    function getCustomRoomName(uint256 location) external view returns (string memory name) {\\n        name = _customRoomNames[location];\\n    }\\n\\n    function getQuest(uint256 characterId, uint64 id) external view returns (uint8 status, string memory data) {\\n        Quest storage quest = _quests[characterId][id];\\n        status = quest.status;\\n        data = quest.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7ac6f1256bdc6325b91b1cf905ed6716791a494d305034e7593c5b7d4e57fbad\"},\"src/dungeon/DungeonMovementFacet.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonFacetBase.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"../utils/BlockHashRegister.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\n\\ncontract DungeonMovementFacet is DungeonFacetBase {\\n    // TODO set better limit for entry range\\n    // TODO class is only really useful when entering for 1st time, create separate function for 1st enter?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external onlyPlayer {\\n        if (_charactersContract.ownerOf(characterId) != address(this)) {\\n            _charactersContract.transferFrom(sender, address(this), characterId);\\n        } else {\\n            require(_charactersContract.getSubOwner(characterId) == 0, \\\"already in dungeon\\\");\\n        }\\n        _charactersContract.setSubOwner(characterId, uint256(sender));\\n        uint256 data = _charactersContract.getData(characterId);\\n        if (data == 0) {\\n            _setCharacterData(\\n                characterId,\\n                CharacterData({\\n                    class: class,\\n                    level: 0,\\n                    xp: 0,\\n                    maxHP: PureDungeon.INITIAL_HP,\\n                    hp: PureDungeon.INITIAL_HP\\n                })\\n            );\\n            _addInitialGears(characterId, 0);\\n        }\\n        if (\\n            location != 0 &&\\n            _rooms[location].kind == PureDungeon.ROOM_TYPE_TELEPORT &&\\n            PureDungeon._getRing(PureDungeon.LOCATION_ZERO, location) < 10\\n        ) {\\n            _characters[characterId].location = location;\\n        } else {\\n            _characters[characterId].location = PureDungeon.LOCATION_ZERO;\\n        }\\n        emit Enter(characterId, sender, name);\\n    }\\n\\n    function exit(uint256 characterId) external onlyPlayer {\\n        require(_characters[characterId].location == PureDungeon.LOCATION_ZERO, \\\"need to reach the entrance\\\");\\n        address subOwner = address(_charactersContract.getSubOwner(characterId));\\n        _charactersContract.transferFrom(address(this), subOwner, characterId);\\n    }\\n\\n    function teleport(uint256 characterId, uint256 teleportLocation) external onlyPlayer {\\n        _blockHashRegister.save();\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = _characters[characterId].location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        require(_rooms[oldLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"current room not a teleport\\\");\\n        require(_rooms[teleportLocation].kind == PureDungeon.ROOM_TYPE_TELEPORT, \\\"destination room not a teleport\\\");\\n        (, ,int64 floor, ) = PureDungeon._coordinates(teleportLocation);\\n        require(_characters[characterId].floors >= floor, \\\"floor not allowed\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 teleportCoinTax = PureDungeon._teleportTax(oldLocation, teleportLocation);\\n        _pay(characterId, oldLocation, PureDungeon.COINS, teleportCoinTax);\\n        emit CharacterMoved(characterId, oldLocation, teleportLocation, 1, PureDungeon.DOWN);\\n        _move(characterId, teleportLocation, PureDungeon.DOWN);\\n    }\\n\\n    function actualiseRoom(uint256 location) external {\\n        _blockHashRegister.save();\\n        _actualiseRoom(location);\\n    }\\n\\n    function move(uint256 characterId, uint8 direction) external onlyPlayer {\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 oldLocation = character.location;\\n        _actualiseRoom(oldLocation);\\n        uint256 monsterIndex = _checkMonster(oldLocation);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[oldLocation].monsterBlockNumber = 0;\\n        uint256 newLocation = _moveTo(characterId, oldLocation, direction);\\n        emit CharacterMoved(characterId, oldLocation, newLocation, 0, direction);\\n        _move(characterId, newLocation, direction);\\n    }\\n\\n    function movePath(uint256 characterId, uint8[] calldata directions) external onlyPlayer {\\n        require(directions.length > 0 && directions.length <= 5, \\\"invalid number of directions\\\");\\n        _blockHashRegister.save();\\n        Character storage character = _characters[characterId];\\n        require(_getCharacterData(characterId).hp > 0, \\\"your character is dead\\\");\\n        uint256 location = character.location;\\n        _actualiseRoom(location);\\n        uint256 monsterIndex = _checkMonster(location);\\n        require(monsterIndex == 0, \\\"monster blocking\\\");\\n        _rooms[location].monsterBlockNumber = 0;\\n        uint256 path = 8;\\n        uint8 direction;\\n        for (uint8 i = 0; i < directions.length && monsterIndex == 0; i++) {\\n            direction = directions[i];\\n            path = (path << 4) + direction;\\n            location = _moveTo(characterId, location, direction);\\n            monsterIndex = _checkMonster(location);\\n        }\\n        emit CharacterMoved(characterId, character.location, location, 2, path);\\n        _move(characterId, location, direction);\\n    }\\n}\\n\",\"keccak256\":\"0x268d93a71951d21a2072b690a0b895dec343c791e70d5980fdd7601a2472d21f\"},\"src/dungeon/DungeonTokenTransferer.sol\":{\"content\":\"pragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"./DungeonMovementFacet.sol\\\";\\nimport \\\"./PureDungeon.sol\\\";\\nimport \\\"./DungeonTokenTransfererDataLayout.sol\\\";\\n\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransferer is Proxied, DungeonTokenTransfererDataLayout {\\n    uint256 public constant MAX_GEARS = 10;\\n\\n    struct Offer {\\n        uint256 characterId;\\n        uint256[8] amounts;\\n        uint256[] gears;\\n    }\\n\\n    event GearSale(uint256 indexed seller, uint256 indexed buyer, uint256 indexed gearId, uint256 price);\\n    event Exchange(uint256 indexed seller, uint256 indexed buyer, Offer sale, Offer price);\\n\\n    function postUpgrade(\\n        DungeonInfoFacet dungeon,\\n        Player player,\\n        Gears gears,\\n        Elements elements,\\n        Characters characters\\n    ) external proxied {\\n        _dungeon = dungeon;\\n        _player = player;\\n        _gears = gears;\\n        _elements = elements;\\n        _characters = characters;\\n    }\\n\\n    modifier onlyPlayer() {\\n        require(msg.sender == address(_player), \\\"only players allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyDungeon() {\\n        require(msg.sender == address(_dungeon), \\\"only dungeon allowed\\\");\\n        _;\\n    }\\n\\n    modifier useCarrier(uint256 character) {\\n        uint256 location = _dungeon.getCharacterLocation(character);\\n        _actualiseRoom(location);\\n        (, , , , , , , , uint8 kind, , ) = _dungeon.getRoomInfo(location);\\n        require(\\n            location == PureDungeon.LOCATION_ZERO || kind == PureDungeon.ROOM_TYPE_CARRIER,\\n            \\\"can only transfer in special room\\\"\\n        );\\n        _elements.subBurnFrom(character, PureDungeon.COINS, PureDungeon._carrierCost(location));\\n        _;\\n    }\\n\\n    function batchTransferGearOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 subOwner = _gears.subOwnerOf(id);\\n            require(subOwner == from, \\\"not subOwner\\\");\\n        }\\n        _gears.batchTransferFrom(address(_dungeon), to, ids);\\n    }\\n\\n    function batchTransferGearIn(uint256 characterId, uint256[] calldata ids) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        _gears.batchTransferFrom(sender, address(_dungeon), ids);\\n        _gears.subBatchTransferFrom(address(_dungeon), 0, characterId, ids);\\n    }\\n\\n    function batchTransferElementsOut(\\n        uint256 from,\\n        address to,\\n        uint256[] calldata amounts\\n    ) external onlyPlayer useCarrier(from) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, 0, id, amount);\\n                _elements.transferFrom(address(_dungeon), to, id, amount);\\n            }\\n        }\\n    }\\n\\n    function batchTransferElementsIn(uint256 characterId, uint256[] calldata amounts) external useCarrier(characterId) {\\n        address sender = _msgSender();\\n        require(_characters.getSubOwner(characterId) == uint256(sender), \\\"subOwner is not sender\\\");\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.transferFrom(sender, address(_dungeon), id, amount);\\n                _elements.subTransferFrom(0, characterId, id, amount);\\n            }\\n        }\\n    }\\n\\n    function drop(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _gears.subTransferFrom(address(_dungeon), from, fromLocation, id);\\n    }\\n\\n    function dropElements(uint256 from, uint256[] calldata amounts) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                uint256 id = i + 1;\\n                _elements.subTransferFrom(from, fromLocation, id, amount);\\n            }\\n        }\\n    }\\n\\n    function pick(uint256 from, uint256 id) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), fromLocation, from, id);\\n    }\\n\\n    function pickElement(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        _elements.subTransferFrom(fromLocation, from, id, amount);\\n    }\\n\\n    function subTransferGearFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        require(_gears.subBalanceOf(from) < MAX_GEARS, \\\"Too many gears\\\");\\n        _gears.subTransferFrom(address(_dungeon), from, to, id);\\n    }\\n\\n    function subTransferElementsFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        uint256 fromLocation = _dungeon.getCharacterLocation(from);\\n        uint256 toLocation = _dungeon.getCharacterLocation(to);\\n        require(fromLocation == toLocation, \\\"need to be in same room\\\");\\n        _elements.subTransferFrom(from, to, id, amount);\\n    }\\n\\n    function scavengeGear(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _gears.subTransferFrom(address(_dungeon), deadCharacterId, characterId, id);\\n    }\\n\\n    function scavengeElements(\\n        uint256 characterId,\\n        uint256 deadCharacterId,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyPlayer {\\n        (uint256 location, , uint256 data, , , , , , , , ) = _dungeon.getCharacterInfo(deadCharacterId);\\n        _actualiseRoom(location);\\n        uint256 scavengerLocation = _dungeon.getCharacterLocation(characterId);\\n        require(location == scavengerLocation, \\\"need to be in same room\\\");\\n        (, uint16 hp, , , ) = PureDungeon._decodeCharacterData(data);\\n        require(hp == 0, \\\"character is not dead\\\");\\n        _elements.subTransferFrom(deadCharacterId, characterId, id, amount);\\n    }\\n\\n    function sellGear(\\n        uint256 seller,\\n        uint256 buyer,\\n        uint256 gearId,\\n        uint256 coins\\n    ) external onlyDungeon {\\n        _elements.subTransferFrom(buyer, seller, 6, coins);\\n        _gears.subTransferFrom(address(_dungeon), seller, buyer, gearId);\\n        emit GearSale(seller, buyer, gearId, coins);\\n    }\\n\\n    function exchange(Offer calldata seller, Offer calldata buyer) external {\\n        for (uint256 i = 0; i < seller.amounts.length; i++) {\\n            uint256 id = i + 1;\\n            if (buyer.amounts[i] > 0) {\\n                _elements.subTransferFrom(buyer.characterId, seller.characterId, id, buyer.amounts[i]);\\n            }\\n            if (seller.amounts[i] > 0) {\\n                _elements.subTransferFrom(seller.characterId, buyer.characterId, id, seller.amounts[i]);\\n            }\\n        }\\n        for (uint256 i = 0; i < seller.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), seller.characterId, buyer.characterId, seller.gears[i]);\\n        }\\n        for (uint256 i = 0; i < buyer.gears.length; i++) {\\n            _gears.subTransferFrom(address(_dungeon), buyer.characterId, seller.characterId, buyer.gears[i]);\\n        }\\n        emit Exchange(seller.characterId, buyer.characterId, seller, buyer);\\n    }\\n\\n    function _msgSender() internal returns (address) {\\n        return msg.sender; // TODO ?\\n    }\\n\\n    function _actualiseRoom(uint256 location) internal {\\n        DungeonMovementFacet(address(_dungeon)).actualiseRoom(location); // TODO DungeonTokenTransferer should be a facet amd DungeonMovementFacet should not expose actualiseRoom\\n    }\\n}\\n\",\"keccak256\":\"0xd8333c01b9c6a01fe63747d15f202f5fe2936636407699b800dd3cc3d631f92c\"},\"src/dungeon/DungeonTokenTransfererDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./DungeonInfoFacet.sol\\\";\\nimport \\\"../tokens/Elements.sol\\\";\\nimport \\\"../tokens/Gears.sol\\\";\\nimport \\\"../player/Player.sol\\\";\\nimport \\\"../characters/Characters.sol\\\";\\n\\ncontract DungeonTokenTransfererDataLayout {\\n    Gears _gears;\\n    Elements _elements;\\n    DungeonInfoFacet _dungeon;\\n    Player _player;\\n    Characters _characters;\\n}\\n\",\"keccak256\":\"0x7e16b426936b58e59347cbdceb71c44071c5c664e25d80091ef2958ce6fb6640\"},\"src/dungeon/PureDungeon.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nlibrary PureDungeon {\\n    uint256 internal constant LOCATION_ZERO = 2**255;\\n\\n    uint8 internal constant ROOM_TYPE_NORMAL = 1;\\n    uint8 internal constant ROOM_TYPE_TELEPORT = 2;\\n    uint8 internal constant ROOM_TYPE_TEMPLE = 3;\\n    uint8 internal constant ROOM_TYPE_LORE = 4;\\n    uint8 internal constant ROOM_TYPE_CARRIER = 5;\\n\\n    uint8 internal constant EXITS_INERTIA = 87;\\n    uint8 internal constant EXITS_BIFURCATION = 40;\\n    uint8 internal constant EXITS_BOTH_BIFURCATION = 25;\\n\\n    uint8 internal constant NORTH = 0;\\n    uint8 internal constant EAST = 1;\\n    uint8 internal constant SOUTH = 2;\\n    uint8 internal constant WEST = 3;\\n    uint8 internal constant DOWN = 4;\\n\\n    uint8 internal constant COINS = 6;\\n    uint8 internal constant KEYS = 7;\\n    uint8 internal constant FRAGMENTS = 8;\\n\\n    uint8 internal constant WARRIOR = 0;\\n    uint8 internal constant EXPLORER = 1;\\n    uint8 internal constant MAGE = 2;\\n    uint8 internal constant BARBARIAN = 3;\\n\\n    uint8 internal constant CLASS_BONUS = 4; // 100/4 = 25%\\n\\n    uint8 internal constant LEVEL_RING_WIDTH = 25;\\n    uint16 internal constant ELEMENT_AREA_10000_PROBA = 100; // 1%\\n    uint8 internal constant NUM_ELEMENT_AREA_PER_PERIOD = 10;\\n\\n    uint8 internal constant LOCK_PROBABILITY = 40;\\n    uint8 internal constant TWO_LOCK_PROBABILITY = 10;\\n\\n    uint8 internal constant MONSTER_SPAWN = 15;\\n\\n    uint8 internal constant INITIAL_HP = 16;\\n    uint8 internal constant HP_INCREASE = 10;\\n\\n    function coordinates(uint256 location)\\n        external\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        return _coordinates(location);\\n    }\\n\\n    function _coordinates(uint256 location)\\n        internal\\n        pure\\n        returns (\\n            int64 x,\\n            int64 y,\\n            int64 z,\\n            uint64 a\\n        )\\n    {\\n        x = int64(location);\\n        y = int64(location / 2**64);\\n        z = int64(location / 2**128);\\n        a = uint64(location / 2**255); // = 1 for valid location\\n    }\\n\\n    function location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) external pure returns (uint256 location) {\\n        return _location(x, y, z);\\n    }\\n\\n    function _location(\\n        int64 x,\\n        int64 y,\\n        int64 z\\n    ) internal pure returns (uint256 location) {\\n        return 2**255 + uint256(uint64(z)) * 2**128 + uint256(uint64(y)) * 2**64 + uint64(x);\\n    }\\n\\n    function generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) external pure returns (uint256) {\\n        return _generateMonsterIndex(location, blockHash, numMonsters, newlyDiscoveredRoom, roomKind);\\n    }\\n\\n    function _generateMonsterIndex(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint256 numMonsters,\\n        bool newlyDiscoveredRoom,\\n        uint8 roomKind\\n    ) internal pure returns (uint256) {\\n        if (roomKind != ROOM_TYPE_NORMAL) {\\n            return 0;\\n        }\\n        uint8 spawnRate = MONSTER_SPAWN;\\n        if (newlyDiscoveredRoom) {\\n            spawnRate += 10;\\n        }\\n        bool hasMonster = uint256(keccak256(abi.encodePacked(location, blockHash, uint8(6)))) % 100 < spawnRate;\\n        if (hasMonster) {\\n            return (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(7)))) % numMonsters) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    function computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) external pure returns (uint256 numGold, uint256 numElements) {\\n        return _computeRoomDiscoveryReward(location, blockHash, class);\\n    }\\n\\n    function _computeRoomDiscoveryReward(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 class\\n    ) internal pure returns (uint256 numGold, uint256 numElements) {\\n        uint256 ring = _getRing(location, 0);\\n        uint256 target = ring / LEVEL_RING_WIDTH;\\n        if (target == 0) {\\n            target = 1;\\n        }\\n        numElements = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(100)))) % target);\\n        if (numElements == 0) {\\n            numElements = 1;\\n        }\\n        if (MAGE == class) {\\n            numElements = numElements + numElements / CLASS_BONUS;\\n        }\\n        if (target > 8) {\\n            target = 8;\\n        }\\n        numGold = (target / 2) + (uint256(keccak256(abi.encodePacked(location, blockHash, uint8(101)))) % target);\\n        if (numGold == 0) {\\n            numGold = 1;\\n        }\\n        if (EXPLORER == class) {\\n            numGold = numGold + numGold / CLASS_BONUS;\\n        }\\n    }\\n\\n    function discoveryCost(uint256 location) external pure returns (uint256 fragments) {\\n        return _discoveryCost(location);\\n    }\\n\\n    function _discoveryCost(uint256 location) internal pure returns (uint256 fragments) {\\n        if (location == LOCATION_ZERO) {\\n            return 0;\\n        } else {\\n            uint256 ring = _getRing(location, 0);\\n            return 1 + ring / LEVEL_RING_WIDTH;\\n        }\\n    }\\n\\n    function generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        external\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        return _generateRandomEvent(areaLoc, blockHash);\\n    }\\n\\n    function _generateRandomEvent(uint256 areaLoc, bytes32 blockHash)\\n        internal\\n        pure\\n        returns (uint256 roomLocation, uint64 randomEvent)\\n    {\\n        roomLocation = _getRoomLoc(\\n            areaLoc,\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(102)))) % 9),\\n            uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(103)))) % 9)\\n        );\\n        randomEvent = 1; // for now always monster TODO :uint64(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(104)))));\\n    }\\n\\n    function generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        external\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        return _generateRoom(location, blockHash, direction, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _generateRoom(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8 exits,\\n            uint8 kind,\\n            uint8 area_discovered\\n        )\\n    {\\n        exits = _generateExits(location, blockHash, direction);\\n        (kind, area_discovered) = _getRoomKind(location, blockHash, areaAtDiscovery, lastIndex, index);\\n    }\\n\\n    function _getRoomKind(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 areaAtDiscovery,\\n        uint8 lastIndex,\\n        uint8 index\\n    ) internal pure returns (uint8 kind, uint8 area_discovered) {\\n        uint256 areaLoc = _getAreaLoc(location);\\n        uint8 currentIndex = lastIndex;\\n        area_discovered = areaAtDiscovery;\\n        (int64 x, int64 y, , ) = _coordinates(location);\\n        if (x == 0 && y == 0) {\\n            // special case // cannot be discovered in batch in one block\\n            kind = ROOM_TYPE_TELEPORT;\\n            area_discovered = area_discovered | 1;\\n        } else {\\n            while (currentIndex <= index) {\\n                uint8 roll = uint8(\\n                    uint256(keccak256(abi.encodePacked(areaLoc, currentIndex, blockHash, uint8(3)))) % 20\\n                );\\n                if (!(area_discovered & 1 == 1) && (roll == 0 || currentIndex == 80)) {\\n                    // if roll or last room\\n                    kind = ROOM_TYPE_TELEPORT;\\n                    area_discovered = area_discovered | 1;\\n                } else if (\\n                    !(area_discovered & 2 == 2) &&\\n                    (roll == 1 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1))) // second last room and teleport not found yet\\n                ) {\\n                    kind = ROOM_TYPE_TEMPLE;\\n                    area_discovered = area_discovered | 2;\\n                } else if (\\n                    !(area_discovered & 4 == 4) &&\\n                    (roll == 2 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2))) // third last room and neither teleport nor temple found yet\\n                ) {\\n                    kind = ROOM_TYPE_LORE;\\n                    area_discovered = area_discovered | 4;\\n                } else if (\\n                    !(area_discovered & 8 == 8) &&\\n                    (roll == 3 ||\\n                        (currentIndex == 80) || // last room\\n                        (currentIndex == 79 && !(area_discovered & 1 == 1)) || // second last room and teleport not found yet\\n                        (currentIndex == 79 && !(area_discovered & 2 == 2)) || // second last room and temple not found yet\\n                        (currentIndex == 79 && !(area_discovered & 4 == 4)) || // second last room and lore not found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 2 == 2)) || // third last room and neither teleport nor temple found yet\\n                        (currentIndex == 78 && !(area_discovered & 1 == 1) && !(area_discovered & 4 == 4)) || // third last room and neither teleport nor lore found yet\\n                        (currentIndex == 78 && !(area_discovered & 4 == 4) && !(area_discovered & 2 == 2)) || // third last room and neither lore nor temple found yet\\n                        (currentIndex == 77 &&\\n                            !(area_discovered & 4 == 4) &&\\n                            !(area_discovered & 2 == 2) &&\\n                            !(area_discovered & 1 == 1))) // fourth last room and neither telport, temple nor lore found yet\\n                ) {\\n                    kind = ROOM_TYPE_CARRIER;\\n                    area_discovered = area_discovered | 8;\\n                } else {\\n                    kind = ROOM_TYPE_NORMAL;\\n                }\\n                currentIndex++;\\n            }\\n        }\\n    }\\n\\n    function toLevelUp(uint16 level)\\n        external\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        return _toLevelUp(level);\\n    }\\n\\n    function _toLevelUp(uint16 level)\\n        internal\\n        pure\\n        returns (\\n            uint16 xpRequired,\\n            uint256 coinsRequired,\\n            uint8 hpIncrease\\n        )\\n    {\\n        uint16[11] memory xpRequirements = [0, 10, 49, 119, 208, 328, 524, 826, 1269, 3654, 6894];\\n        xpRequired = xpRequirements[level];\\n        if (level > 8) {\\n            coinsRequired = 492;\\n        } else {\\n            coinsRequired = (((1 + level) ** 3) / 5) + 8;\\n        }\\n        hpIncrease = HP_INCREASE;\\n    }\\n\\n    function generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) external pure returns (uint8 areaType) {\\n        _generateArea(areaLoc, blockHash, numElementalAreaInPeriod);\\n    }\\n\\n    function _generateArea(\\n        uint256 areaLoc,\\n        bytes32 blockHash,\\n        uint64 numElementalAreaInPeriod\\n    ) internal pure returns (uint8 areaType) {\\n        if (_isCentreArea(areaLoc) || numElementalAreaInPeriod >= NUM_ELEMENT_AREA_PER_PERIOD) {\\n            areaType = 6;\\n        } else {\\n            uint256 roomRing = (_getAreaRing(areaLoc) * 9);\\n            if (roomRing > 0) {\\n                roomRing -= 4; // this set the value to be the one of the corner room nearest to the center\\n            }\\n            if (roomRing >= LEVEL_RING_WIDTH) {\\n                bool elementArea = uint8(uint256(keccak256(abi.encodePacked(areaLoc, blockHash, uint8(12)))) % 10000) <=\\n                    ELEMENT_AREA_10000_PROBA;\\n                if (elementArea) {\\n                    (, ,int64 z, ) = _coordinates(areaLoc);\\n                    areaType = 1 + uint8(z % 5);\\n                } else {\\n                    areaType = 6;\\n                }\\n            } else {\\n                areaType = 6;\\n            }\\n        }\\n    }\\n\\n    // distance between 2 location * 0.4\\n    function teleportTax(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _teleportTax(p1, p2);\\n    }\\n\\n    function _teleportTax(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(p1, p2)) / 5;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function carrierCost(uint256 location) external pure returns (uint256) {\\n        return _carrierCost(location);\\n    }\\n\\n    function _carrierCost(uint256 location) internal pure returns (uint256) {\\n        uint256 cost = (2 * _getRing(location, LOCATION_ZERO)) / 6;\\n        if (cost == 0) {\\n            return 1;\\n        } else {\\n            return cost;\\n        }\\n    }\\n\\n    function recyclingReward(uint256 gearData) external pure returns (uint256) {\\n        return _recyclingReward(gearData);\\n    }\\n\\n    function _recyclingReward(uint256 gearData) internal pure returns (uint256) {\\n        (uint16 level, , , uint16 durability, uint16 maxDurability, ) = _decodeGearData(gearData);\\n        uint256 reward = 1 + level / 2;\\n        if (durability == maxDurability) {\\n            reward += 1 + reward / 2;\\n        }\\n        return reward;\\n    }\\n\\n    function hpCost(uint16 hp) external pure returns (uint256) {\\n        return _hpCost(hp);\\n    }\\n\\n    function _hpCost(uint16 hp) internal pure returns (uint256) {\\n        return hp * 5;\\n    }\\n\\n    function getRing(uint256 p1, uint256 p2) external pure returns (uint256) {\\n        return _getRing(p1, p2);\\n    }\\n\\n    function _getRing(uint256 p1, uint256 p2) internal pure returns (uint256) {\\n        (int64 x1, int64 y1, , ) = _coordinates(p1);\\n        (int64 x2, int64 y2, , ) = _coordinates(p2);\\n        int256 dx = x1 - x2;\\n        if (dx < 0) {\\n            dx = -dx;\\n        }\\n        int256 dy = y1 - y2;\\n        if (dy < 0) {\\n            dy = -dy;\\n        }\\n        if (dx > 2**64 / 2) {\\n            dx = 2**64 - dx;\\n        }\\n        if (dy > 2**64 / 2) {\\n            dy = 2**64 - dy;\\n        }\\n        if (dx > dy) {\\n            return uint256(dx);\\n        } else {\\n            return uint256(dy);\\n        }\\n    }\\n\\n    function _getAreaRing(uint256 areaLoc) internal pure returns (uint64) {\\n        (int64 x, int64 y, , ) = _coordinates(areaLoc);\\n        if (x < 0) {\\n            x = -x;\\n        }\\n        if (y < 0) {\\n            y = -y;\\n        }\\n        if (x > y) {\\n            return uint64(x);\\n        } else {\\n            return uint64(y);\\n        }\\n    }\\n\\n    // centre area is currently defined as the first 9 area (first area + 8 surrounding it)\\n    function _isCentreArea(uint256 areaLoc) internal pure returns (bool) {\\n        (int64 areaX, int64 areaY, , ) = _coordinates(areaLoc);\\n        return areaX >= -1 && areaY >= -1 && areaX <= 1 && areaY <= 1;\\n    }\\n\\n    function getAreaLoc(uint256 location) external pure returns (uint256) {\\n        return _getAreaLoc(location);\\n    }\\n\\n    function _getAreaLoc(uint256 location) internal pure returns (uint256) {\\n        (int64 x, int64 y, int64 z, ) = _coordinates(location);\\n        int64 areaX;\\n        if (x >= 0) {\\n            areaX = (x + 4) / 9;\\n        } else {\\n            areaX = -((-x + 4) / 9);\\n        }\\n\\n        int64 areaY;\\n        if (y >= 0) {\\n            areaY = (y + 4) / 9;\\n        } else {\\n            areaY = -((-y + 4) / 9);\\n        }\\n        return _location(areaX, areaY, z);\\n    }\\n\\n    function _getRoomLoc(\\n        uint256 areaLoc,\\n        uint8 x,\\n        uint8 y\\n    ) internal pure returns (uint256) {\\n        (int64 areaX, int64 areaY, int64 floor, ) = _coordinates(areaLoc);\\n        return _location(areaX * 9 - 4 + x, areaY * 9 - 4 + y, floor);\\n    }\\n\\n    // direction based exit generation\\n    // both exits and locks are generated\\n    // return value is encoded (uint4 locksBits, uint4 exitBits)\\n    function _generateExits(\\n        uint256 location,\\n        bytes32 blockHash,\\n        uint8 direction\\n    ) internal pure returns (uint8) {\\n        uint8 exits = 0;\\n        if (DOWN == direction) {\\n            exits = 0xF;\\n        } else {\\n            if (EXITS_INERTIA > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(1)))) % 100)) {\\n                exits = 2**direction;\\n            }\\n            if (EXITS_BIFURCATION > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(2)))) % 100)) {\\n                if (\\n                    EXITS_BOTH_BIFURCATION >\\n                    uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)\\n                ) {\\n                    if (NORTH == direction || SOUTH == direction) {\\n                        exits = (exits | 8) | 2;\\n                    } else if (EAST == direction || WEST == direction) {\\n                        exits = (exits | 1) | 4;\\n                    }\\n                } else {\\n                    if (50 > uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(3)))) % 100)) {\\n                        if (NORTH == direction) {\\n                            exits |= 8;\\n                        } else if (EAST == direction) {\\n                            exits |= 1;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 2;\\n                        } else if (WEST == direction) {\\n                            exits |= 4;\\n                        }\\n                    } else {\\n                        if (NORTH == direction) {\\n                            exits |= 2;\\n                        } else if (EAST == direction) {\\n                            exits |= 4;\\n                        } else if (SOUTH == direction) {\\n                            exits |= 8;\\n                        } else if (WEST == direction) {\\n                            exits |= 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        uint8 randLock = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(111)))) % 100);\\n        uint8 numLocks = randLock < (100 - LOCK_PROBABILITY) ? 0 : (randLock < (100 - TWO_LOCK_PROBABILITY) ? 1 : 2);\\n        if (numLocks >= 4) {\\n            exits = exits | (15 * 2**4);\\n        } else if (numLocks == 3) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            uint8 locks = (chosenLocks + 1) * 7;\\n            if (locks == 21) {\\n                exits = exits | (13 * 2**4);\\n            } else if (locks == 28) {\\n                exits = exits | (11 * 2**4);\\n            }\\n            // 4 possibilities : 7 // 14 // 13 // 11\\n        } else if (numLocks == 2) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 6);\\n            uint8 locks = (chosenLocks + 1) * 3;\\n            if (locks == 15) {\\n                exits = exits | (5 * 2**4);\\n            } else if (locks == 18) {\\n                exits = exits | (10 * 2**4);\\n            }\\n            // 3 // 6 // 9 // 12 // 5 // 10\\n        } else if (numLocks == 1) {\\n            uint8 chosenLocks = uint8(uint256(keccak256(abi.encodePacked(location, blockHash, uint8(112)))) % 4);\\n            exits = exits | (2**chosenLocks * 2**4);\\n        }\\n        return exits;\\n    }\\n\\n    function decodeCharacterData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        return _decodeCharacterData(data);\\n    }\\n\\n    function _decodeCharacterData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint16 hp,\\n            uint16 maxHP,\\n            uint32 xp,\\n            uint8 class\\n        )\\n    {\\n        class = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        xp = uint32((data >> 200) % 2**32);\\n        maxHP = uint16((data >> 184) % 2**16);\\n        hp = uint16((data >> 168) % 2**16);\\n    }\\n\\n    function encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) external pure returns (uint256 data) {\\n        return _encodeGearData(level, slot, classBits, durability, maxDurability, template);\\n    }\\n\\n    function _encodeGearData(\\n        uint16 level,\\n        uint8 slot,\\n        uint8 classBits,\\n        uint16 durability,\\n        uint16 maxDurability,\\n        uint32 template\\n    ) internal pure returns (uint256 data) {\\n        return ((uint256(classBits) << 248) +\\n            (uint256(level) << 232) +\\n            (uint256(slot) << 224) +\\n            (uint256(durability) << 208) +\\n            (uint256(maxDurability) << 192) +\\n            template);\\n    }\\n\\n    function decodeGearData(uint256 data)\\n        external\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        return _decodeGearData(data);\\n    }\\n\\n    function _decodeGearData(uint256 data)\\n        internal\\n        pure\\n        returns (\\n            uint16 level,\\n            uint8 slot,\\n            uint8 classBits,\\n            uint16 durability,\\n            uint16 maxDurability,\\n            uint32 template\\n        )\\n    {\\n        classBits = uint8(data >> 248);\\n        level = uint16((data >> 232) % 2**16);\\n        slot = uint8((data >> 224) % 2**8);\\n        durability = uint16((data >> 208) % 2**16);\\n        maxDurability = uint16((data >> 192) % 2**16);\\n        template = uint32(data % 2**32);\\n    }\\n\\n    function limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) external pure returns (uint16) {\\n        return _limitedChange(value, max, change);\\n    }\\n\\n    function _limitedChange(\\n        uint16 value,\\n        uint16 max,\\n        int64 change\\n    ) internal pure returns (uint16) {\\n        int64 updated = int64(value) + int64(change);\\n        if (updated > int64(max)) {\\n            return max;\\n        }\\n        if (updated <= 0) {\\n            return 0;\\n        } else {\\n            return uint16(updated);\\n        }\\n    }\\n\\n    function roomsTax(uint256 rooms) external pure returns (uint256) {\\n        return _roomsTax(rooms);\\n    }\\n    function _roomsTax(uint256 rooms) internal pure returns (uint256) {\\n        return 1 + rooms / 10;\\n    }\\n}\\n\",\"keccak256\":\"0xa1e6437a43c5f9686778c7f0b6ea6998d623f202f8aed28f60ad4e0e442e7e3e\"},\"src/player/Player.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./PlayerDataLayout.sol\\\";\\n\\ncontract Player is Proxied, PlayerDataLayout {\\n    event Call(bool success, bytes returnData);\\n    event Refill(address indexed playerAddress, uint256 newEnergy);\\n\\n    function postUpgrade(\\n        Characters charactersContract,\\n        address payable feeRecipient,\\n        uint256 minBalance\\n    ) external proxied {\\n        _charactersContract = charactersContract;\\n        _feeRecipient = feeRecipient;\\n        MIN_BALANCE = minBalance;\\n    }\\n\\n    function register() external {\\n        if (msg.sender != address(_holder)) {\\n            require(address(_holder) == address(0), \\\"holder already set\\\");\\n            _holder = Enterable(msg.sender);\\n        }\\n    }\\n\\n    function getLastCharacterId(address playerAddress) external view returns (uint256) {\\n        return _lastCharacterIds[playerAddress];\\n    }\\n\\n    function getPlayerInfo(address playerAddress, uint256 characterId)\\n        external\\n        view\\n        returns (uint256 energy, uint256 freeEnergy)\\n    {\\n        Player storage player = _players[playerAddress];\\n        energy = player.energy;\\n        freeEnergy = player.freeEnergy;\\n    }\\n\\n    function createAndEnter(\\n        address payable newDelegate,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        uint256 characterId = _charactersContract.mintTo(address(_holder));\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string calldata name,\\n        uint8 class,\\n        uint256 location\\n    ) external payable {\\n        _charactersContract.transferFrom(msg.sender, address(_holder), characterId);\\n        _enter(newDelegate, characterId, value, name, class, location);\\n    }\\n\\n    function _enter(\\n        address payable newDelegate,\\n        uint256 characterId,\\n        uint256 value,\\n        string memory name,\\n        uint8 class,\\n        uint256 location\\n    ) internal {\\n        require(msg.value >= value, \\\"msg.value < value\\\");\\n        if (msg.value > value) {\\n            _refill(msg.value - value);\\n        }\\n        if (newDelegate != address(0)) {\\n            _addDelegate(newDelegate);\\n        }\\n        _holder.enter.value(value)(msg.sender, characterId, name, class, location);\\n        _lastCharacterIds[msg.sender] = characterId;\\n    }\\n\\n    function callAsCharacter(\\n        address destination,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData) {\\n        // TODO check death ?\\n        require(destination != address(this), \\\"cannot call itself\\\");\\n        // TODO block data if == `enter(address sender, uint256 characterId, bytes data)`\\n        uint256 initialGas = gasleft();\\n        uint256 characterId = _getFirstParam(data);\\n        require(_charactersContract.ownerOf(characterId) == address(_holder), \\\"_holder does not own character\\\");\\n        uint256 playerAddress = _charactersContract.getSubOwner(characterId);\\n        if (uint256(msg.sender) != playerAddress) {\\n            require(uint256(_delegates[msg.sender]) == playerAddress, \\\"sender is not delegate of character's player\\\");\\n        }\\n        Player storage player = _players[address(playerAddress)];\\n        uint256 energy = player.energy;\\n\\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, data);\\n\\n        uint256 balanceCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\\n        // TODO remove *10\\n        uint256 freeEnergyFee = (balanceCharge * 10) / 100;\\n        // TODO remove *10\\n        uint256 fee = balanceCharge * 10;\\n        require(energy >= freeEnergyFee + fee, \\\"not enough energy\\\");\\n        energy -= (freeEnergyFee + fee);\\n        _feeRecipient.send(fee);\\n        // TODO _feeRecipient as Pool\\n\\n        // TODO use Metatx instead of local private key holding fund\\n        if (msg.sender.balance < MIN_BALANCE) {\\n            uint256 balanceToGive = MIN_BALANCE - msg.sender.balance;\\n            if (balanceToGive >= energy) {\\n                balanceToGive = energy;\\n                energy = 0;\\n            } else {\\n                energy -= balanceToGive;\\n            }\\n\\n            if (balanceToGive > 0) {\\n                msg.sender.transfer(balanceToGive);\\n            }\\n        }\\n        player.freeEnergy += uint128(freeEnergyFee);\\n        player.energy = uint128(energy);\\n\\n        emit Call(success, returnData);\\n    }\\n\\n    function isDelegateFor(address delegate, address playerAddress) external view returns (bool) {\\n        return _delegates[delegate] == playerAddress;\\n    }\\n\\n    function refill() public payable {\\n        _refill(msg.value);\\n    }\\n\\n    function _refill(uint256 value) internal {\\n        _players[msg.sender].energy += uint128(value);\\n        emit Refill(msg.sender, _players[msg.sender].energy);\\n    }\\n\\n    // TODO add Events for Delegates\\n    function addDelegate(address payable _delegate) public payable {\\n        if (msg.value > 0) {\\n            _refill(msg.value);\\n        }\\n        _addDelegate(_delegate);\\n    }\\n\\n    function _addDelegate(address payable _delegate) public payable {\\n        require(_delegate != address(0), \\\"no zero address delegate\\\");\\n        require(_players[msg.sender].energy >= uint128(MIN_BALANCE), \\\"not enough energy\\\");\\n        _players[msg.sender].energy -= uint128(MIN_BALANCE);\\n        _delegate.transfer(MIN_BALANCE);\\n        _delegates[_delegate] = msg.sender;\\n    }\\n\\n    function _getFirstParam(bytes memory data) internal pure returns (uint256) {\\n        if (data.length < 36) {\\n            return 0;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value;\\n    }\\n\\n    function _executeWithSpecificGas(\\n        address to,\\n        uint256 gasLimit,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        (success, returnData) = to.call.gas(gasLimit)(data);\\n        assert(gasleft() > gasLimit / 63);\\n        // not enough gas provided, assert to throw all gas // TODO use EIP-1930\\n    }\\n}\\n\",\"keccak256\":\"0x1b29df1bc9d7eb406726977624a9b77b61d2cd1a4ff5b1e5a45e9378ae0e1b9c\"},\"src/player/PlayerDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"../characters/Characters.sol\\\";\\n\\ninterface Enterable {\\n    // TODO generalize?\\n    function enter(\\n        address sender,\\n        uint256 characterId,\\n        string calldata data,\\n        uint8 class,\\n        uint256 location\\n    ) external payable;\\n}\\n\\ncontract PlayerDataLayout {\\n    uint256 internal MIN_BALANCE; // = 5000000000000000;\\n\\n    struct Player {\\n        uint128 energy;\\n        uint128 freeEnergy;\\n    }\\n\\n    address payable _feeRecipient;\\n    mapping(address => address) _delegates;\\n    mapping(address => Player) _players;\\n    mapping(address => uint256) _lastCharacterIds;\\n\\n    Characters _charactersContract;\\n    Enterable _holder;\\n}\\n\",\"keccak256\":\"0x51937d1f4fe454e2fceadab8545288a8af637783ac0f5b4b3cb5996808645dbf\"},\"src/tokens/ERC1155Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC1155TokenDataLayout.sol\\\";\\n\\ncontract ERC1155Token is Proxied, ERC1155TokenDataLayout {\\n    event TransferSingle(address indexed from, address indexed to, uint256 indexed id, uint256 amount);\\n    event TransferBatch(address indexed from, address indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event SubTransferSingle(uint256 indexed from, uint256 indexed to, uint256 indexed id, uint256 amount);\\n    event SubTransferBatch(uint256 indexed from, uint256 indexed to, uint256[] indexed ids, uint256[] amounts);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function postUpgrade(address tokenOwner) public virtual proxied {\\n        _tokenOwner = tokenOwner;\\n    }\\n\\n    function mintTo(\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _balances[owner][id] += amount;\\n        emit TransferSingle(address(0), owner, id, amount);\\n    }\\n\\n    function mint(\\n        uint256 subOwner,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(msg.sender == _tokenOwner, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subBalances[subOwner][id] += amount;\\n        _balances[_tokenOwner][id] += amount;\\n        emit TransferSingle(address(0), _tokenOwner, id, amount);\\n        emit SubTransferSingle(0, subOwner, id, amount);\\n    }\\n\\n    function subBurnFrom(\\n        uint256 from,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _balances[_tokenOwner][id] -= amount;\\n        emit TransferSingle(_tokenOwner, address(0), id, amount);\\n        emit SubTransferSingle(from, 0, id, amount);\\n    }\\n\\n    function batchSubBurnFrom(\\n        uint256 from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(\\n            _tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender],\\n            \\\"NOT_AUTHORIZED_BATCH_SUB_BURN\\\"\\n        );\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _subBalances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _subBalances[from][id] = currentBalance - amount;\\n            _balances[_tokenOwner][id] -= amount;\\n        }\\n        emit TransferBatch(_tokenOwner, address(0), ids, amounts);\\n        emit SubTransferBatch(from, 0, ids, amounts);\\n    }\\n\\n    function subBalanceOf(uint256 who, uint256 id) public view returns (uint256) {\\n        return _subBalances[who][id];\\n    }\\n\\n    function subBalanceOfBatch(uint256[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = subBalanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    function subTransferFrom(\\n        uint256 from,\\n        uint256 to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        // cannot do any sender like in ERC721 because we would need to keep track of which owner is the balance coming from\\n        require(_tokenOwner == msg.sender || _operatorsForAll[_tokenOwner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        uint256 currentBalance = _subBalances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _subBalances[from][id] = currentBalance - amount;\\n        _subBalances[to][id] += amount;\\n        emit SubTransferSingle(from, to, id, amount);\\n    }\\n\\n    function balanceOf(address who, uint256 id) public view returns (uint256) {\\n        require(who != address(0), \\\"zero address\\\");\\n        return _balances[who][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(owners.length == ids.length, \\\"Inconsistent array length between args\\\");\\n        uint256[] memory balances = new uint256[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            balances[i] = balanceOf(owners[i], ids[i]);\\n        }\\n        return balances;\\n    }\\n\\n    // TODO ERC1155 use safe version only\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external {\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        uint256 currentBalance = _balances[from][id];\\n        require(currentBalance >= amount, \\\"does not own enough\\\");\\n        _balances[from][id] = currentBalance - amount;\\n        _balances[to][id] += amount;\\n        emit TransferSingle(from, to, id, amount);\\n    }\\n\\n    // onwer need to take responsibility to subBurn before transfering out\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external {\\n        require(ids.length == amounts.length, \\\"Inconsistent length\\\");\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            uint256 currentBalance = _balances[from][id];\\n            require(currentBalance >= amount, \\\"does not own enough\\\");\\n            _balances[from][id] = currentBalance - amount;\\n            _balances[to][id] += amount;\\n        }\\n        emit TransferBatch(from, to, ids, amounts);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x07e039b9b9013c02d30aac5e97ba264934836bab2e8a3118819dea416a8ccb30\"},\"src/tokens/ERC1155TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC1155TokenDataLayout {\\n    mapping(address => mapping(uint256 => uint256)) internal _balances; // TODO pack balances into one unit256\\n    mapping(uint256 => mapping(uint256 => uint256)) internal _subBalances; // TODO pack balances into one unit256\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\n    address _tokenOwner; //the dungeon\\n}\\n\",\"keccak256\":\"0xdd21c84c06255dd0e075f96c495bfe5641ab182e1b64e921bdd36447825f80f2\"},\"src/tokens/ERC721Token.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"buidler-deploy/solc_0.6/proxy/Proxied.sol\\\";\\nimport \\\"./ERC721TokenDataLayout.sol\\\";\\n\\ncontract ERC721Token is Proxied, ERC721TokenDataLayout {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n    event SubTransfer(uint256 indexed from, uint256 indexed to, uint256 indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event DataUpdate(uint256 indexed id, uint256 indexed data);\\n\\n    function postUpgrade(address dungeon) public virtual proxied {\\n        _minter = dungeon;\\n    }\\n\\n    function subBalanceOf(uint256 subOwner) external view returns (uint256) {\\n        return _subNumNFTPerAddress[subOwner];\\n    }\\n\\n    function mint(uint256 subOwner, uint256 data) public returns (uint256 id) {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        id = ++_lastId;\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n\\n    // TODO make sure that data of gear/room in vault cannot be changed\\n    function setData(uint256 id, uint256 data) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SET_DATA\\\");\\n        _data[id] = data;\\n        emit DataUpdate(id, data);\\n    }\\n\\n    function getData(uint256 id) external view returns (uint256) {\\n        return _data[id];\\n    }\\n\\n    function subBurn(uint256 id) external {\\n        address owner = _owners[id];\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BURN\\\");\\n        uint256 subOwner = _subOwners[id];\\n        _subOwners[id] = 0;\\n        _subNumNFTPerAddress[subOwner]--;\\n        emit SubTransfer(subOwner, 0, id);\\n    }\\n\\n    function subOwnerOf(uint256 id) public view returns (uint256) {\\n        return _subOwners[id];\\n    }\\n\\n    function ownerOf(uint256 id) public view returns (address) {\\n        address owner = _owners[id];\\n        require(owner != address(0), \\\"token does not exist\\\");\\n        return owner;\\n    }\\n\\n    function subTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256 id\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_TRANSFER\\\");\\n        require(owner == _owners[id], \\\"not owner\\\");\\n        uint256 subOwner = _subOwners[id];\\n        require(subOwner == from, \\\"not subOnwer\\\");\\n        _subOwners[id] = to;\\n        _subNumNFTPerAddress[subOwner]--;\\n        _subNumNFTPerAddress[to]++;\\n        emit SubTransfer(from, to, id);\\n    }\\n\\n    function subBatchTransferFrom(\\n        address owner,\\n        uint256 from,\\n        uint256 to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(owner == msg.sender || _operatorsForAll[owner][msg.sender], \\\"NOT_AUTHORIZED_SUB_BATCH_TRANSFER\\\");\\n        uint256 numIds = ids.length;\\n        for (uint256 i = 0; i < numIds; i++) {\\n            uint256 id = ids[i];\\n            require(owner == _owners[id], \\\"not owner\\\");\\n            uint256 subOwner = _subOwners[id];\\n            require(subOwner == from, \\\"not subOnwer\\\");\\n            _subOwners[id] = to;\\n            emit SubTransfer(from, to, id);\\n        }\\n        _subNumNFTPerAddress[from] -= numIds;\\n        _subNumNFTPerAddress[to] += numIds;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_TRANSFER\\\");\\n        address owner = _owners[id];\\n        require(owner == from, \\\"not owner\\\");\\n        _owners[id] = to;\\n        uint256 subOwner = _subOwners[id];\\n        if (_subOwners[id] != 0) {\\n            _subOwners[id] = 0;\\n            _subNumNFTPerAddress[subOwner]--;\\n            emit SubTransfer(subOwner, 0, id);\\n        }\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids\\n    ) external {\\n        require(to != address(0), \\\"invalid to\\\");\\n        require(from == msg.sender || _operatorsForAll[from][msg.sender], \\\"NOT_AUTHORIZED_BATCH_TRANSFER\\\");\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            address owner = _owners[id];\\n            require(owner == from, \\\"not owner\\\");\\n            _owners[id] = to;\\n            uint256 subOwner = _subOwners[id];\\n            if (_subOwners[id] != 0) {\\n                _subOwners[id] = 0;\\n                _subNumNFTPerAddress[subOwner]--;\\n                emit SubTransfer(subOwner, 0, id);\\n            }\\n            emit Transfer(from, to, id); // TODO extract function (same as transferFrom)\\n        }\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorsForAll[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n}\\n\",\"keccak256\":\"0x0e0b76aeb5c792803b2b750cf124709b231ebf0e47c5b408ebae0fb6f4b944f1\"},\"src/tokens/ERC721TokenDataLayout.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract ERC721TokenDataLayout {\\n    address internal _minter;\\n    uint256 internal _lastId;\\n    mapping(uint256 => address) internal _owners;\\n    mapping(uint256 => uint256) internal _subOwners;\\n\\n    mapping(uint256 => uint256) internal _subNumNFTPerAddress;\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    mapping(uint256 => uint256) internal _data;\\n}\\n\",\"keccak256\":\"0xf389950923ea0618a2da366fb1726d4c6c60c507c5fad43fe9f1317f614a8553\"},\"src/tokens/Elements.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC1155Token.sol\\\";\\n\\ncontract Elements is ERC1155Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x5111ca6032430f85a7cb526c3ff0331fbbc398cbb8ceb52e96f73159cc47233f\"},\"src/tokens/Gears.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Gears is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n}\\n\",\"keccak256\":\"0x6e1e20651a266c4ab8fba8e4f90c321d30101f24348da6803b0bae6711fdef3c\"},\"src/tokens/Rooms.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ncontract Rooms is ERC721Token {\\n    function postUpgrade(address dungeon) public override {\\n        super.postUpgrade(dungeon);\\n    }\\n\\n    function mintId(uint256 id, uint256 subOwner) public {\\n        require(msg.sender == _minter, \\\"NOT_AUTHORIZED_MINT\\\");\\n        _subOwners[id] = subOwner;\\n        _subNumNFTPerAddress[subOwner]++;\\n        _owners[id] = _minter;\\n        emit Transfer(address(0), _minter, id);\\n        emit SubTransfer(0, subOwner, id);\\n    }\\n}\\n\",\"keccak256\":\"0x3241793b303d5eb5eb327e8036d6f06a3ed631daedf34e55806b3dea8c3a6573\"},\"src/utils/BlockHashRegister.sol\":{\"content\":\"pragma solidity 0.6.5;\\n\\ncontract BlockHashRegister {\\n    mapping(uint256 => bytes32) _blockHashes;\\n    uint256 _blockToActualise;\\n\\n    event HashRequest(uint256 blockNumber);\\n\\n    function get(uint256 blockNumber) external view returns (bytes32) {\\n        return _blockHashes[blockNumber];\\n    }\\n\\n    function getOrCompute(uint256 blockNumber) external view returns (bytes32) {\\n        bytes32 blockHash = _blockHashes[blockNumber];\\n        if (uint256(blockHash) == 0) {\\n            return _computeBlockHash(blockNumber);\\n        }\\n        return blockHash;\\n    }\\n\\n    function getBlockToActualise() external view returns (uint256) {\\n        return _blockToActualise;\\n    }\\n\\n    function request() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = block.number;\\n            emit HashRequest(block.number);\\n        }\\n    }\\n\\n    function save() external {\\n        uint256 blockNumber = _blockToActualise;\\n        if (blockNumber < block.number) {\\n            _save(blockNumber);\\n            _blockToActualise = 0;\\n        }\\n    }\\n\\n    function _computeBlockHash(uint256 blockNumber) internal view returns (bytes32) {\\n        if (blockNumber < 256 || blockNumber > block.number - 256) {\\n            return blockhash(blockNumber);\\n        } else {\\n            uint256 moduloBlockNumber = block.number - ((block.number - blockNumber - 1) % 256) + 1;\\n            return blockhash(moduloBlockNumber);\\n        }\\n    }\\n\\n    function _save(uint256 blockNumber) internal returns (bytes32) {\\n        bytes32 blockHash = _computeBlockHash(blockNumber);\\n        _blockHashes[blockNumber] = blockHash;\\n        return blockHash;\\n    }\\n}\\n\",\"keccak256\":\"0xbf9f49a9ee6426191a58a2796f50ca4652c8dd635e120aadb277cf2ffb2f0cc9\"}},\"version\":1}",
                                      "bytecode": "0x608060405234801561001057600080fd5b50612a8e806100206000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220e88b35fc8855a53b0b75ce8d16fa7e3a5eb5e79103ba9da8db3398e1af92dae264736f6c63430006050033",
                                      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c80639a6e7a8311610097578063c681677811610066578063c6816778146101f6578063c983e09214610209578063dfe11fd51461021c578063ffa629771461022f57610100565b80639a6e7a831461019f578063a62f4550146101bd578063b832e0a9146101d0578063c4ca0636146101e357610100565b80634a0dfcb6116100d35780634a0dfcb614610153578063563bcd8d146101665780637e6975b91461017957806386d5b7d51461018c57610100565b8063024a271e146101055780630309451f1461011a5780630bd7041d1461012d5780632854823714610140575b600080fd5b6101186101133660046124e6565b610242565b005b610118610128366004612421565b6104ae565b61011861013b366004612338565b6107dc565b61011861014e366004612511565b6108b0565b6101186101613660046124e6565b610abe565b610118610174366004612511565b610c94565b61011861018736600461247b565b610e56565b61011861019a366004612511565b611168565b6101a76112a8565b6040516101b491906129d3565b60405180910390f35b6101186101cb3660046124c5565b6112ad565b6101186101de3660046124e6565b61146c565b6101186101f13660046123a8565b611586565b6101186102043660046124c5565b61187c565b610118610217366004612421565b611963565b61011861022a36600461247b565b611c5b565b61011861023d36600461247b565b611fd4565b6003546001600160a01b031633146102755760405162461bcd60e51b815260040161026c90612918565b60405180910390fd5b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906102a69087906004016129d3565b60206040518083038186803b1580156102be57600080fd5b505afa1580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b29061032c9087906004016129d3565b60206040518083038186803b15801561034457600080fd5b505afa158015610358573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037c9190612409565b905080821461039d5760405162461bcd60e51b815260040161026c90612852565b60005460405163c9a59e4760e01b8152600a916001600160a01b03169063c9a59e47906103ce9089906004016129d3565b60206040518083038186803b1580156103e657600080fd5b505afa1580156103fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061041e9190612409565b1061043b5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892610475929116908990899089906004016127e3565b600060405180830381600087803b15801561048f57600080fd5b505af11580156104a3573d6000803e3d6000fd5b505050505050505050565b6003546001600160a01b031633146104d85760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b29061050d9085906004016129d3565b60206040518083038186803b15801561052557600080fd5b505afa158015610539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061055d9190612409565b90506105688161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b5906105999085906004016129d3565b6101606040518083038186803b1580156105b257600080fd5b505afa1580156105c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ea9190612542565b505098505050505050505050600160ff1b82148061060b575060ff81166005145b6106275760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e384600661064486612189565b6040518463ffffffff1660e01b8152600401610662939291906129dc565b600060405180830381600087803b15801561067c57600080fd5b505af1158015610690573d6000803e3d6000fd5b506000925050505b848110156107665760008686838181106106ae57fe5b600080546040516369f648a160e01b8152602090930294909401359450926001600160a01b031691506369f648a1906106eb9085906004016129d3565b60206040518083038186803b15801561070357600080fd5b505afa158015610717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073b9190612409565b905089811461075c5760405162461bcd60e51b815260040161026c906128b1565b5050600101610698565b5060005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926107a1929116908a908a908a90600401612755565b600060405180830381600087803b1580156107bb57600080fd5b505af11580156107cf573d6000803e3d6000fd5b5050505050505050505050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03811661083b576001600160a01b037fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610355610850565b336001600160a01b0382161461085057600080fd5b50600280546001600160a01b03199081166001600160a01b03978816179091556003805482169587169590951790945560008054851693861693909317909255600180548416918516919091179055600480549092169216919091179055565b6003546001600160a01b031633146108da5760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d8301909061090e9088906004016129d3565b6101606040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190612605565b505050505050505092505091506109758261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906109a6908a906004016129d3565b60206040518083038186803b1580156109be57600080fd5b505afa1580156109d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f69190612409565b9050808314610a175760405162461bcd60e51b815260040161026c90612852565b6000610a22836121c0565b5050509150508061ffff16600014610a4c5760405162461bcd60e51b815260040161026c90612976565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610a82908a908c908b908b90600401612809565b600060405180830381600087803b158015610a9c57600080fd5b505af1158015610ab0573d6000803e3d6000fd5b505050505050505050505050565b6003546001600160a01b03163314610ae85760405162461bcd60e51b815260040161026c90612918565b60025460405162d8301960e41b815260009182916001600160a01b0390911690630d83019090610b1c9087906004016129d3565b6101606040518083038186803b158015610b3557600080fd5b505afa158015610b49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6d9190612605565b50505050505050509250509150610b838261212b565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610bb49089906004016129d3565b60206040518083038186803b158015610bcc57600080fd5b505afa158015610be0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c049190612409565b9050808314610c255760405162461bcd60e51b815260040161026c90612852565b6000610c30836121c0565b5050509150508061ffff16600014610c5a5760405162461bcd60e51b815260040161026c90612976565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b6721898926107a1929116908a908c908b906004016127e3565b6003546001600160a01b03163314610cbe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b290610cef9088906004016129d3565b60206040518083038186803b158015610d0757600080fd5b505afa158015610d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3f9190612409565b60025460405163283171d960e11b81529192506000916001600160a01b0390911690635062e3b290610d759088906004016129d3565b60206040518083038186803b158015610d8d57600080fd5b505afa158015610da1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc59190612409565b9050808214610de65760405162461bcd60e51b815260040161026c90612852565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb90610e1c908990899089908990600401612809565b600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050505050505050565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290610e8b9085906004016129d3565b60206040518083038186803b158015610ea357600080fd5b505afa158015610eb7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610edb9190612409565b9050610ee68161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590610f179085906004016129d3565b6101606040518083038186803b158015610f3057600080fd5b505afa158015610f44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f689190612542565b505098505050505050505050600160ff1b821480610f89575060ff81166005145b610fa55760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006610fc286612189565b6040518463ffffffff1660e01b8152600401610fe0939291906129dc565b600060405180830381600087803b158015610ffa57600080fd5b505af115801561100e573d6000803e3d6000fd5b50505050600061101c6121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611051918c91016129d3565b60206040518083038186803b15801561106957600080fd5b505afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190612409565b146110be5760405162461bcd60e51b815260040161026c90612946565b60005460025460405163f3993d1160e01b81526001600160a01b039283169263f3993d11926110f9928692909116908b908b90600401612755565b600060405180830381600087803b15801561111357600080fd5b505af1158015611127573d6000803e3d6000fd5b505060008054600254604051637ba764f760e01b81526001600160a01b039283169550637ba764f794506107a19391909216918c908c908c906004016127b5565b6002546001600160a01b031633146111925760405162461bcd60e51b815260040161026c90612824565b6001546040516311aa10fb60e01b81526001600160a01b03909116906311aa10fb906111c990869088906006908790600401612809565b600060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b50506000546002546040516316ce431360e31b81526001600160a01b03928316945063b6721898935061123692909116908890889088906004016127e3565b600060405180830381600087803b15801561125057600080fd5b505af1158015611264573d6000803e3d6000fd5b505050508183857f198e2ac2be3d740936b958f72f2ff48636882d544f3f03603725be8ae80f4f858460405161129a91906129d3565b60405180910390a450505050565b600a81565b6003546001600160a01b031633146112d75760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906113089086906004016129d3565b60206040518083038186803b15801561132057600080fd5b505afa158015611334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113589190612409565b60005460405163c9a59e4760e01b8152919250600a916001600160a01b039091169063c9a59e479061138e9087906004016129d3565b60206040518083038186803b1580156113a657600080fd5b505afa1580156113ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113de9190612409565b106113fb5760405162461bcd60e51b815260040161026c90612889565b6000546002546040516316ce431360e31b81526001600160a01b039283169263b672189892611435929116908590889088906004016127e3565b600060405180830381600087803b15801561144f57600080fd5b505af1158015611463573d6000803e3d6000fd5b50505050505050565b6003546001600160a01b031633146114965760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906114c79087906004016129d3565b60206040518083038186803b1580156114df57600080fd5b505afa1580156114f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115179190612409565b6001546040516311aa10fb60e01b81529192506001600160a01b0316906311aa10fb9061154e908490889088908890600401612809565b600060405180830381600087803b15801561156857600080fd5b505af115801561157c573d6000803e3d6000fd5b5050505050505050565b60005b60088110156116cf576001810160006020840183600881106115a757fe5b6020020135111561162e576001546001600160a01b03166311aa10fb84358635846020880187600881106115d757fe5b60200201356040518563ffffffff1660e01b81526004016115fb9493929190612809565b600060405180830381600087803b15801561161557600080fd5b505af1158015611629573d6000803e3d6000fd5b505050505b600084602001836008811061163f57fe5b602002013511156116c6576001546001600160a01b03166311aa10fb853585358460208901876008811061166f57fe5b60200201356040518563ffffffff1660e01b81526004016116939493929190612809565b600060405180830381600087803b1580156116ad57600080fd5b505af11580156116c1573d6000803e3d6000fd5b505050505b50600101611589565b5060005b6116e16101208401846129f5565b9050811015611783576000546002546001600160a01b039182169163b67218989116853585356117156101208901896129f5565b8781811061171f57fe5b905060200201356040518563ffffffff1660e01b815260040161174594939291906127e3565b600060405180830381600087803b15801561175f57600080fd5b505af1158015611773573d6000803e3d6000fd5b5050600190920191506116d39050565b5060005b6117956101208301836129f5565b9050811015611837576000546002546001600160a01b039182169163b67218989116843586356117c96101208801886129f5565b878181106117d357fe5b905060200201356040518563ffffffff1660e01b81526004016117f994939291906127e3565b600060405180830381600087803b15801561181357600080fd5b505af1158015611827573d6000803e3d6000fd5b5050600190920191506117879050565b506040518135908335907fd475a0c010a34f4afb9b3cafe6a6005f2f2603913ec4cd25d812b510d5caa9079061187090869086906129a5565b60405180910390a35050565b6003546001600160a01b031633146118a65760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b2906118d79086906004016129d3565b60206040518083038186803b1580156118ef57600080fd5b505afa158015611903573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119279190612409565b6000546002546040516316ce431360e31b81529293506001600160a01b039182169263b6721898926114359216908790869088906004016127e3565b6003546001600160a01b0316331461198d5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b815285916000916001600160a01b0390911690635062e3b2906119c29085906004016129d3565b60206040518083038186803b1580156119da57600080fd5b505afa1580156119ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a129190612409565b9050611a1d8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611a4e9085906004016129d3565b6101606040518083038186803b158015611a6757600080fd5b505afa158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190612542565b505098505050505050505050600160ff1b821480611ac0575060ff81166005145b611adc5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611af986612189565b6040518463ffffffff1660e01b8152600401611b17939291906129dc565b600060405180830381600087803b158015611b3157600080fd5b505af1158015611b45573d6000803e3d6000fd5b506000925050505b8481101561157c576000868683818110611b6357fe5b9050602002013590506000811115611c5257600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb90611bb1908d9060009086908890600401612809565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b5050600154600254604051637f4c824d60e11b81526001600160a01b03928316945063fe99049a9350611c1e92909116908d908690889060040161278c565b600060405180830381600087803b158015611c3857600080fd5b505af1158015611c4c573d6000803e3d6000fd5b50505050505b50600101611b4d565b60025460405163283171d960e11b815284916000916001600160a01b0390911690635062e3b290611c909085906004016129d3565b60206040518083038186803b158015611ca857600080fd5b505afa158015611cbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ce09190612409565b9050611ceb8161212b565b600254604051636790d2b560e01b81526000916001600160a01b031690636790d2b590611d1c9085906004016129d3565b6101606040518083038186803b158015611d3557600080fd5b505afa158015611d49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6d9190612542565b505098505050505050505050600160ff1b821480611d8e575060ff81166005145b611daa5760405162461bcd60e51b815260040161026c906128d7565b6001546001600160a01b031663c9b902e3846006611dc786612189565b6040518463ffffffff1660e01b8152600401611de5939291906129dc565b600060405180830381600087803b158015611dff57600080fd5b505af1158015611e13573d6000803e3d6000fd5b505050506000611e216121f1565b60048054604051630607176160e31b81529293506001600160a01b0380851693911691633038bb0891611e56918c91016129d3565b60206040518083038186803b158015611e6e57600080fd5b505afa158015611e82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea69190612409565b14611ec35760405162461bcd60e51b815260040161026c90612946565b60005b8581101561157c576000878783818110611edc57fe5b9050602002013590506000811115611fcb5760018054600254604051637f4c824d60e11b8152928501926001600160a01b039283169263fe99049a92611f2e928992909116908690889060040161278c565b600060405180830381600087803b158015611f4857600080fd5b505af1158015611f5c573d6000803e3d6000fd5b50506001546040516311aa10fb60e01b81526001600160a01b0390911692506311aa10fb9150611f97906000908e9086908890600401612809565b600060405180830381600087803b158015611fb157600080fd5b505af1158015611fc5573d6000803e3d6000fd5b50505050505b50600101611ec6565b6003546001600160a01b03163314611ffe5760405162461bcd60e51b815260040161026c90612918565b60025460405163283171d960e11b81526000916001600160a01b031690635062e3b29061202f9087906004016129d3565b60206040518083038186803b15801561204757600080fd5b505afa15801561205b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207f9190612409565b905060005b8281101561212457600084848381811061209a57fe5b905060200201359050600081111561211b57600180546040516311aa10fb60e01b8152918401916001600160a01b03909116906311aa10fb906120e7908a90889086908890600401612809565b600060405180830381600087803b15801561210157600080fd5b505af1158015612115573d6000803e3d6000fd5b50505050505b50600101612084565b5050505050565b60025460405163236501cf60e21b81526001600160a01b0390911690638d94073c9061215b9084906004016129d3565b600060405180830381600087803b15801561217557600080fd5b505af1158015612124573d6000803e3d6000fd5b600080600661219c84600160ff1b6121f5565b600202816121a657fe5b049050806121b85760019150506121bb565b90505b919050565b61ffff60e882901c81169260a883901c82169260b881901c9092169163ffffffff60c882901c169160f89190911c90565b3390565b600080600061220385612293565b50509150915060008061221586612293565b5091935091505081840360070b600081121561222f576000035b81840360070b6000811215612242576000035b6001603f1b8213156122585781600160401b0391505b6001603f1b81131561226b57600160401b035b808213156122805750945061228d9350505050565b955061228d945050505050565b92915050565b90600160401b820490600160801b830490600160ff1b840490565b60008083601f8401126122bf578182fd5b50813567ffffffffffffffff8111156122d6578182fd5b60208301915083602080830285010111156122f057600080fd5b9250929050565b60006101408284031215612309578081fd5b50919050565b805167ffffffffffffffff8116811461228d57600080fd5b805160ff8116811461228d57600080fd5b600080600080600060a0868803121561234f578081fd5b853561235a81612a40565b9450602086013561236a81612a40565b9350604086013561237a81612a40565b9250606086013561238a81612a40565b9150608086013561239a81612a40565b809150509295509295909350565b600080604083850312156123ba578182fd5b823567ffffffffffffffff808211156123d1578384fd5b6123dd868387016122f7565b935060208501359150808211156123f2578283fd5b506123ff858286016122f7565b9150509250929050565b60006020828403121561241a578081fd5b5051919050565b60008060008060608587031215612436578384fd5b84359350602085013561244881612a40565b9250604085013567ffffffffffffffff811115612463578283fd5b61246f878288016122ae565b95989497509550505050565b60008060006040848603121561248f578283fd5b83359250602084013567ffffffffffffffff8111156124ac578283fd5b6124b8868287016122ae565b9497909650939450505050565b600080604083850312156124d7578182fd5b50508035926020909101359150565b6000806000606084860312156124fa578283fd5b505081359360208301359350604090920135919050565b60008060008060808587031215612526578384fd5b5050823594602084013594506040840135936060013592509050565b60008060008060008060008060008060006101608c8e031215612563578889fd5b8b519a5060208c0151995061257b8d60408e01612327565b985061258a8d60608e01612327565b97506125998d60808e01612327565b96506125a88d60a08e01612327565b955060c08c015180151581146125bc578586fd5b94506125cb8d60e08e0161230f565b93506125db8d6101008e01612327565b92506125eb8d6101208e0161230f565b91506101408c015190509295989b509295989b9093969950565b60008060008060008060008060008060006101608c8e031215612626578485fd5b8b519a506126378d60208e01612327565b995060408c0151985060608c0151975060808c0151965060a08c0151955060c08c0151945060e08c015193506101008c01518060070b8114612677578182fd5b6101208d01516101408e0151919450925061269181612a40565b809150509295989b509295989b9093969950565b81835260006001600160fb1b038311156126bd578081fd5b6020830280836020870137939093016020019283525090919050565b60006101408235845261010060208401602086013761012080850183815281850135601e1986360301811261270c578485fd5b85019150813567ffffffffffffffff811115612726578485fd5b602081023603861315612737578485fd5b83825261274a84880182602086016126a5565b979650505050505050565b6001600160a01b0385811682528416602082015260606040820181905260009061278290830184866126a5565b9695505050505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060018060a01b03871682528560208301528460408301526080606083015261274a6080830184866126a5565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b93845260208401929092526040830152606082015260800190565b6020808252601490820152731bdb9b1e48191d5b99d95bdb88185b1b1bddd95960621b604082015260600190565b60208082526017908201527f6e65656420746f20626520696e2073616d6520726f6f6d000000000000000000604082015260600190565b6020808252600e908201526d546f6f206d616e7920676561727360901b604082015260600190565b6020808252600c908201526b3737ba1039bab127bbb732b960a11b604082015260600190565b60208082526021908201527f63616e206f6e6c79207472616e7366657220696e207370656369616c20726f6f6040820152606d60f81b606082015260800190565b6020808252601490820152731bdb9b1e481c1b185e595c9cc8185b1b1bddd95960621b604082015260600190565b60208082526016908201527539bab127bbb732b91034b9903737ba1039b2b73232b960511b604082015260600190565b60208082526015908201527418da185c9858dd195c881a5cc81b9bdd0819195859605a1b604082015260600190565b6000604082526129b860408301856126d9565b82810360208401526129ca81856126d9565b95945050505050565b90815260200190565b92835260ff919091166020830152604082015260600190565b6000808335601e19843603018112612a0b578283fd5b8084018035925067ffffffffffffffff831115612a26578384fd5b60208101935050506020810236038213156122f057600080fd5b6001600160a01b0381168114612a5557600080fd5b5056fea2646970667358221220e88b35fc8855a53b0b75ce8d16fa7e3a5eb5e79103ba9da8db3398e1af92dae264736f6c63430006050033",
                                      "execute": {
                                        "methodName": "postUpgrade",
                                        "args": [
                                          "0xF7CdA62EE1A8B09f883424994D5744dc74F29fee",
                                          "0x3e2aDFf2924dEFf4337864573AE54c4129425799",
                                          "0x05eeB47724cd8d1CfAF2BAc324A23B07d2e69d12",
                                          "0x51A784FfC7958Cf054A0e85267a38941bFf13197",
                                          "0x6FFcB7378b31b2117c4F7ed9B2a7f1f634DDA5d4"
                                        ]
                                      },
                                      "devdoc": {
                                        "methods": {}
                                      },
                                      "userdoc": {
                                        "methods": {}
                                      },
                                      "storageLayout": {
                                        "storage": [
                                          {
                                            "astId": 6515,
                                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                            "label": "_gears",
                                            "offset": 0,
                                            "slot": "0",
                                            "type": "t_contract(Gears)11871"
                                          },
                                          {
                                            "astId": 6517,
                                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                            "label": "_elements",
                                            "offset": 0,
                                            "slot": "1",
                                            "type": "t_contract(Elements)11852"
                                          },
                                          {
                                            "astId": 6519,
                                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                            "label": "_dungeon",
                                            "offset": 0,
                                            "slot": "2",
                                            "type": "t_contract(DungeonInfoFacet)4939"
                                          },
                                          {
                                            "astId": 6521,
                                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                            "label": "_player",
                                            "offset": 0,
                                            "slot": "3",
                                            "type": "t_contract(Player)10254"
                                          },
                                          {
                                            "astId": 6523,
                                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                            "label": "_characters",
                                            "offset": 0,
                                            "slot": "4",
                                            "type": "t_contract(Characters)469"
                                          }
                                        ],
                                        "types": {
                                          "t_contract(Characters)469": {
                                            "encoding": "inplace",
                                            "label": "contract Characters",
                                            "numberOfBytes": "20"
                                          },
                                          "t_contract(DungeonInfoFacet)4939": {
                                            "encoding": "inplace",
                                            "label": "contract DungeonInfoFacet",
                                            "numberOfBytes": "20"
                                          },
                                          "t_contract(Elements)11852": {
                                            "encoding": "inplace",
                                            "label": "contract Elements",
                                            "numberOfBytes": "20"
                                          },
                                          "t_contract(Gears)11871": {
                                            "encoding": "inplace",
                                            "label": "contract Gears",
                                            "numberOfBytes": "20"
                                          },
                                          "t_contract(Player)10254": {
                                            "encoding": "inplace",
                                            "label": "contract Player",
                                            "numberOfBytes": "20"
                                          }
                                        }
                                      }
                                    }
                                  ],
                                  "devdoc": {
                                    "methods": {}
                                  },
                                  "userdoc": {
                                    "methods": {}
                                  },
                                  "storageLayout": {
                                    "storage": [
                                      {
                                        "astId": 6517,
                                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                        "label": "_gears",
                                        "offset": 0,
                                        "slot": "0",
                                        "type": "t_contract(Gears)11873"
                                      },
                                      {
                                        "astId": 6519,
                                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                        "label": "_elements",
                                        "offset": 0,
                                        "slot": "1",
                                        "type": "t_contract(Elements)11854"
                                      },
                                      {
                                        "astId": 6521,
                                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                        "label": "_dungeon",
                                        "offset": 0,
                                        "slot": "2",
                                        "type": "t_contract(DungeonInfoFacet)4942"
                                      },
                                      {
                                        "astId": 6523,
                                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                        "label": "_player",
                                        "offset": 0,
                                        "slot": "3",
                                        "type": "t_contract(Player)10256"
                                      },
                                      {
                                        "astId": 6525,
                                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                        "label": "_characters",
                                        "offset": 0,
                                        "slot": "4",
                                        "type": "t_contract(Characters)469"
                                      }
                                    ],
                                    "types": {
                                      "t_contract(Characters)469": {
                                        "encoding": "inplace",
                                        "label": "contract Characters",
                                        "numberOfBytes": "20"
                                      },
                                      "t_contract(DungeonInfoFacet)4942": {
                                        "encoding": "inplace",
                                        "label": "contract DungeonInfoFacet",
                                        "numberOfBytes": "20"
                                      },
                                      "t_contract(Elements)11854": {
                                        "encoding": "inplace",
                                        "label": "contract Elements",
                                        "numberOfBytes": "20"
                                      },
                                      "t_contract(Gears)11873": {
                                        "encoding": "inplace",
                                        "label": "contract Gears",
                                        "numberOfBytes": "20"
                                      },
                                      "t_contract(Player)10256": {
                                        "encoding": "inplace",
                                        "label": "contract Player",
                                        "numberOfBytes": "20"
                                      }
                                    }
                                  }
                                }
                              ],
                              "devdoc": {
                                "methods": {}
                              },
                              "userdoc": {
                                "methods": {}
                              },
                              "storageLayout": {
                                "storage": [
                                  {
                                    "astId": 6517,
                                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                    "label": "_gears",
                                    "offset": 0,
                                    "slot": "0",
                                    "type": "t_contract(Gears)11955"
                                  },
                                  {
                                    "astId": 6519,
                                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                    "label": "_elements",
                                    "offset": 0,
                                    "slot": "1",
                                    "type": "t_contract(Elements)11936"
                                  },
                                  {
                                    "astId": 6521,
                                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                    "label": "_dungeon",
                                    "offset": 0,
                                    "slot": "2",
                                    "type": "t_contract(DungeonInfoFacet)4942"
                                  },
                                  {
                                    "astId": 6523,
                                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                    "label": "_player",
                                    "offset": 0,
                                    "slot": "3",
                                    "type": "t_contract(Player)10256"
                                  },
                                  {
                                    "astId": 6525,
                                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                    "label": "_characters",
                                    "offset": 0,
                                    "slot": "4",
                                    "type": "t_contract(Characters)469"
                                  }
                                ],
                                "types": {
                                  "t_contract(Characters)469": {
                                    "encoding": "inplace",
                                    "label": "contract Characters",
                                    "numberOfBytes": "20"
                                  },
                                  "t_contract(DungeonInfoFacet)4942": {
                                    "encoding": "inplace",
                                    "label": "contract DungeonInfoFacet",
                                    "numberOfBytes": "20"
                                  },
                                  "t_contract(Elements)11936": {
                                    "encoding": "inplace",
                                    "label": "contract Elements",
                                    "numberOfBytes": "20"
                                  },
                                  "t_contract(Gears)11955": {
                                    "encoding": "inplace",
                                    "label": "contract Gears",
                                    "numberOfBytes": "20"
                                  },
                                  "t_contract(Player)10256": {
                                    "encoding": "inplace",
                                    "label": "contract Player",
                                    "numberOfBytes": "20"
                                  }
                                }
                              }
                            }
                          ],
                          "devdoc": {
                            "methods": {}
                          },
                          "userdoc": {
                            "methods": {}
                          },
                          "storageLayout": {
                            "storage": [
                              {
                                "astId": 6517,
                                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                "label": "_gears",
                                "offset": 0,
                                "slot": "0",
                                "type": "t_contract(Gears)11953"
                              },
                              {
                                "astId": 6519,
                                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                "label": "_elements",
                                "offset": 0,
                                "slot": "1",
                                "type": "t_contract(Elements)11934"
                              },
                              {
                                "astId": 6521,
                                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                "label": "_dungeon",
                                "offset": 0,
                                "slot": "2",
                                "type": "t_contract(DungeonInfoFacet)4942"
                              },
                              {
                                "astId": 6523,
                                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                "label": "_player",
                                "offset": 0,
                                "slot": "3",
                                "type": "t_contract(Player)10254"
                              },
                              {
                                "astId": 6525,
                                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                                "label": "_characters",
                                "offset": 0,
                                "slot": "4",
                                "type": "t_contract(Characters)469"
                              }
                            ],
                            "types": {
                              "t_contract(Characters)469": {
                                "encoding": "inplace",
                                "label": "contract Characters",
                                "numberOfBytes": "20"
                              },
                              "t_contract(DungeonInfoFacet)4942": {
                                "encoding": "inplace",
                                "label": "contract DungeonInfoFacet",
                                "numberOfBytes": "20"
                              },
                              "t_contract(Elements)11934": {
                                "encoding": "inplace",
                                "label": "contract Elements",
                                "numberOfBytes": "20"
                              },
                              "t_contract(Gears)11953": {
                                "encoding": "inplace",
                                "label": "contract Gears",
                                "numberOfBytes": "20"
                              },
                              "t_contract(Player)10254": {
                                "encoding": "inplace",
                                "label": "contract Player",
                                "numberOfBytes": "20"
                              }
                            }
                          }
                        }
                      ],
                      "devdoc": {
                        "methods": {}
                      },
                      "userdoc": {
                        "methods": {}
                      },
                      "storageLayout": {
                        "storage": [
                          {
                            "astId": 6517,
                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                            "label": "_gears",
                            "offset": 0,
                            "slot": "0",
                            "type": "t_contract(Gears)11953"
                          },
                          {
                            "astId": 6519,
                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                            "label": "_elements",
                            "offset": 0,
                            "slot": "1",
                            "type": "t_contract(Elements)11934"
                          },
                          {
                            "astId": 6521,
                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                            "label": "_dungeon",
                            "offset": 0,
                            "slot": "2",
                            "type": "t_contract(DungeonInfoFacet)4942"
                          },
                          {
                            "astId": 6523,
                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                            "label": "_player",
                            "offset": 0,
                            "slot": "3",
                            "type": "t_contract(Player)10254"
                          },
                          {
                            "astId": 6525,
                            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                            "label": "_characters",
                            "offset": 0,
                            "slot": "4",
                            "type": "t_contract(Characters)469"
                          }
                        ],
                        "types": {
                          "t_contract(Characters)469": {
                            "encoding": "inplace",
                            "label": "contract Characters",
                            "numberOfBytes": "20"
                          },
                          "t_contract(DungeonInfoFacet)4942": {
                            "encoding": "inplace",
                            "label": "contract DungeonInfoFacet",
                            "numberOfBytes": "20"
                          },
                          "t_contract(Elements)11934": {
                            "encoding": "inplace",
                            "label": "contract Elements",
                            "numberOfBytes": "20"
                          },
                          "t_contract(Gears)11953": {
                            "encoding": "inplace",
                            "label": "contract Gears",
                            "numberOfBytes": "20"
                          },
                          "t_contract(Player)10254": {
                            "encoding": "inplace",
                            "label": "contract Player",
                            "numberOfBytes": "20"
                          }
                        }
                      }
                    }
                  ],
                  "devdoc": {
                    "methods": {}
                  },
                  "userdoc": {
                    "methods": {}
                  },
                  "storageLayout": {
                    "storage": [
                      {
                        "astId": 6517,
                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                        "label": "_gears",
                        "offset": 0,
                        "slot": "0",
                        "type": "t_contract(Gears)12549"
                      },
                      {
                        "astId": 6519,
                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                        "label": "_elements",
                        "offset": 0,
                        "slot": "1",
                        "type": "t_contract(Elements)12530"
                      },
                      {
                        "astId": 6521,
                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                        "label": "_dungeon",
                        "offset": 0,
                        "slot": "2",
                        "type": "t_contract(DungeonInfoFacet)4942"
                      },
                      {
                        "astId": 6523,
                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                        "label": "_player",
                        "offset": 0,
                        "slot": "3",
                        "type": "t_contract(Player)10400"
                      },
                      {
                        "astId": 6525,
                        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                        "label": "_characters",
                        "offset": 0,
                        "slot": "4",
                        "type": "t_contract(Characters)469"
                      }
                    ],
                    "types": {
                      "t_contract(Characters)469": {
                        "encoding": "inplace",
                        "label": "contract Characters",
                        "numberOfBytes": "20"
                      },
                      "t_contract(DungeonInfoFacet)4942": {
                        "encoding": "inplace",
                        "label": "contract DungeonInfoFacet",
                        "numberOfBytes": "20"
                      },
                      "t_contract(Elements)12530": {
                        "encoding": "inplace",
                        "label": "contract Elements",
                        "numberOfBytes": "20"
                      },
                      "t_contract(Gears)12549": {
                        "encoding": "inplace",
                        "label": "contract Gears",
                        "numberOfBytes": "20"
                      },
                      "t_contract(Player)10400": {
                        "encoding": "inplace",
                        "label": "contract Player",
                        "numberOfBytes": "20"
                      }
                    }
                  }
                }
              ],
              "devdoc": {
                "methods": {}
              },
              "userdoc": {
                "methods": {}
              },
              "storageLayout": {
                "storage": [
                  {
                    "astId": 6517,
                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                    "label": "_gears",
                    "offset": 0,
                    "slot": "0",
                    "type": "t_contract(Gears)12551"
                  },
                  {
                    "astId": 6519,
                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                    "label": "_elements",
                    "offset": 0,
                    "slot": "1",
                    "type": "t_contract(Elements)12532"
                  },
                  {
                    "astId": 6521,
                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                    "label": "_dungeon",
                    "offset": 0,
                    "slot": "2",
                    "type": "t_contract(DungeonInfoFacet)4942"
                  },
                  {
                    "astId": 6523,
                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                    "label": "_player",
                    "offset": 0,
                    "slot": "3",
                    "type": "t_contract(Player)10400"
                  },
                  {
                    "astId": 6525,
                    "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                    "label": "_characters",
                    "offset": 0,
                    "slot": "4",
                    "type": "t_contract(Characters)469"
                  }
                ],
                "types": {
                  "t_contract(Characters)469": {
                    "encoding": "inplace",
                    "label": "contract Characters",
                    "numberOfBytes": "20"
                  },
                  "t_contract(DungeonInfoFacet)4942": {
                    "encoding": "inplace",
                    "label": "contract DungeonInfoFacet",
                    "numberOfBytes": "20"
                  },
                  "t_contract(Elements)12532": {
                    "encoding": "inplace",
                    "label": "contract Elements",
                    "numberOfBytes": "20"
                  },
                  "t_contract(Gears)12551": {
                    "encoding": "inplace",
                    "label": "contract Gears",
                    "numberOfBytes": "20"
                  },
                  "t_contract(Player)10400": {
                    "encoding": "inplace",
                    "label": "contract Player",
                    "numberOfBytes": "20"
                  }
                }
              }
            }
          ],
          "devdoc": {
            "methods": {}
          },
          "userdoc": {
            "methods": {}
          },
          "storageLayout": {
            "storage": [
              {
                "astId": 6534,
                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                "label": "_gears",
                "offset": 0,
                "slot": "0",
                "type": "t_contract(Gears)12579"
              },
              {
                "astId": 6536,
                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                "label": "_elements",
                "offset": 0,
                "slot": "1",
                "type": "t_contract(Elements)12560"
              },
              {
                "astId": 6538,
                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                "label": "_dungeon",
                "offset": 0,
                "slot": "2",
                "type": "t_contract(DungeonInfoFacet)4959"
              },
              {
                "astId": 6540,
                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                "label": "_player",
                "offset": 0,
                "slot": "3",
                "type": "t_contract(Player)10428"
              },
              {
                "astId": 6542,
                "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
                "label": "_characters",
                "offset": 0,
                "slot": "4",
                "type": "t_contract(Characters)469"
              }
            ],
            "types": {
              "t_contract(Characters)469": {
                "encoding": "inplace",
                "label": "contract Characters",
                "numberOfBytes": "20"
              },
              "t_contract(DungeonInfoFacet)4959": {
                "encoding": "inplace",
                "label": "contract DungeonInfoFacet",
                "numberOfBytes": "20"
              },
              "t_contract(Elements)12560": {
                "encoding": "inplace",
                "label": "contract Elements",
                "numberOfBytes": "20"
              },
              "t_contract(Gears)12579": {
                "encoding": "inplace",
                "label": "contract Gears",
                "numberOfBytes": "20"
              },
              "t_contract(Player)10428": {
                "encoding": "inplace",
                "label": "contract Player",
                "numberOfBytes": "20"
              }
            }
          }
        }
      ],
      "devdoc": {
        "methods": {}
      },
      "userdoc": {
        "methods": {}
      },
      "storageLayout": {
        "storage": [
          {
            "astId": 6744,
            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
            "label": "_gears",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(Gears)12822"
          },
          {
            "astId": 6746,
            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
            "label": "_elements",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(Elements)12803"
          },
          {
            "astId": 6748,
            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
            "label": "_dungeon",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(DungeonInfoFacet)5169"
          },
          {
            "astId": 6750,
            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
            "label": "_player",
            "offset": 0,
            "slot": "3",
            "type": "t_contract(Player)10671"
          },
          {
            "astId": 6752,
            "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
            "label": "_characters",
            "offset": 0,
            "slot": "4",
            "type": "t_contract(Characters)469"
          }
        ],
        "types": {
          "t_contract(Characters)469": {
            "encoding": "inplace",
            "label": "contract Characters",
            "numberOfBytes": "20"
          },
          "t_contract(DungeonInfoFacet)5169": {
            "encoding": "inplace",
            "label": "contract DungeonInfoFacet",
            "numberOfBytes": "20"
          },
          "t_contract(Elements)12803": {
            "encoding": "inplace",
            "label": "contract Elements",
            "numberOfBytes": "20"
          },
          "t_contract(Gears)12822": {
            "encoding": "inplace",
            "label": "contract Gears",
            "numberOfBytes": "20"
          },
          "t_contract(Player)10671": {
            "encoding": "inplace",
            "label": "contract Player",
            "numberOfBytes": "20"
          }
        }
      }
    }
  ],
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6756,
        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
        "label": "_gears",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Gears)12834"
      },
      {
        "astId": 6758,
        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
        "label": "_elements",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Elements)12815"
      },
      {
        "astId": 6760,
        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
        "label": "_dungeon",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(DungeonInfoFacet)5181"
      },
      {
        "astId": 6762,
        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
        "label": "_player",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(Player)10683"
      },
      {
        "astId": 6764,
        "contract": "src/dungeon/DungeonTokenTransferer.sol:DungeonTokenTransferer",
        "label": "_characters",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(Characters)469"
      }
    ],
    "types": {
      "t_contract(Characters)469": {
        "encoding": "inplace",
        "label": "contract Characters",
        "numberOfBytes": "20"
      },
      "t_contract(DungeonInfoFacet)5181": {
        "encoding": "inplace",
        "label": "contract DungeonInfoFacet",
        "numberOfBytes": "20"
      },
      "t_contract(Elements)12815": {
        "encoding": "inplace",
        "label": "contract Elements",
        "numberOfBytes": "20"
      },
      "t_contract(Gears)12834": {
        "encoding": "inplace",
        "label": "contract Gears",
        "numberOfBytes": "20"
      },
      "t_contract(Player)10683": {
        "encoding": "inplace",
        "label": "contract Player",
        "numberOfBytes": "20"
      }
    }
  }
}